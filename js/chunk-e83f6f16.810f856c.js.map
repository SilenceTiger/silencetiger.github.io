{"version":3,"sources":["webpack:///./node_modules/parcoord-es/dist/parcoords.esm.js","webpack:///./node_modules/requestanimationframe/app/requestAnimationFrame.js"],"names":["__webpack_require__","d3_selection__WEBPACK_IMPORTED_MODULE_1__","d3_brush__WEBPACK_IMPORTED_MODULE_2__","d3_drag__WEBPACK_IMPORTED_MODULE_3__","d3_shape__WEBPACK_IMPORTED_MODULE_4__","d3_scale__WEBPACK_IMPORTED_MODULE_5__","d3_array__WEBPACK_IMPORTED_MODULE_6__","d3_collection__WEBPACK_IMPORTED_MODULE_7__","d3_axis__WEBPACK_IMPORTED_MODULE_8__","d3_dispatch__WEBPACK_IMPORTED_MODULE_9__","renderQueue","func","_queue","_rate","_invalidate","_clear","rq","data","render","valid","doFrame","chunk","splice","map","requestAnimationFrame","invalidate","slice","add","concat","rate","value","arguments","length","remaining","clear","w","config","width","margin","right","left","invertCategorical","selection","scale","domain","range","found","forEach","d","i","push","invertByScale","invert","brushExtents","state","pc","extents","brushes","brushNodes","Object","keys","dimensions","reduce","acc","cur","brush","undefined","raw","yScale","yscale","scaled","extent","brushSelections","g","selectAll","each","this","dim","yExtent","call","move","reverse","renderBrushed","_this","brushReset","dimension","brushed","type","event","selected","brushGroup","is_brushed","p","actives","filter","_brushRange","within","date","bandwidth","number","string","predicate","every","some","Error","brushPredicate","brushUpdated","events","args","newSelection","brushFor","axis","_selector","hasOwnProperty","brushRangeMax","_brush","convertBrushArguments","args_array","Array","prototype","node","on","sourceEvent","stopPropagation","install","createAxes","append","attr","style","uninstall","remove","install1DAxes","modes","brushState","drawBrushes","selector","brushSelection$$1","id","enter","insert","b","indexOf","brushObject","exit","selected$1","pos","axisBrushes","document","getElementById","dimExt","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","e","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_e","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_e2","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","brushUpdated$1","newBrush","lastBrushID","lastBrush","toString","brushExtents$1","yExtents","_bs","j","ext","f","k","_this$1","brushReset$1","axisBrush","select","brushFor$1","install$1","uninstall$1","install1DMultiAxes","uninstall$2","strumRect","containmentTest","strum","p1","minX","p2","m1","b1","m2","b2","x","y","y1","y2","Math","min","max","crossesStrum","strums","test","d1","dims","d2","point","selected$2","ids","getOwnPropertyNames","isNaN","crossTest","removeStrum","active","svg","onDragEnd","drawStrum","activePoint","_svg","points","_line","circles","_drag","ev","maxX","minY","maxY","onDrag","top","h","height","bottom","dimensionsForPoint","xscale","getOrderedDimensionKeys","onDragStart","brushReset$2","consecutive","first","second","keys$$1","install$2","install2DStrums","uninstall$3","hypothenuse","a","sqrt","signedAngle","angle","PI","containmentTest$1","arc$$1","startAngle","endAngle","tmp","crossesStrum$1","arcs","c","asin","selected$3","removeStrum$1","onDragEnd$1","arc","outerRadius","drawStrum$1","p3","_path","onDrag$1","onDragStart$1","innerRadius","brushReset$3","sAngle","uAngle","install$3","installAngularBrush","intersection","mergeParcoords","callback","devicePixelRatio","window","mergedCanvas","createElement","foregroundCanvas","canvas","foreground","canvasMarginLeft","Number","marginLeft","replace","textTopAdjust","canvasMarginTop","marginTop","clientWidth","clientHeight","context","getContext","key","fillStyle","fillRect","drawImage","URL","webkitURL","serializer","XMLSerializer","svgNodeCopy","cloneNode","setAttribute","getAttribute","svgStr","serializeToString","src","btoa","img","Image","onload","selected$4","ranges","nodes","__data__","values","ranger","includes","flipAxes","unshift","ii","dimRange","_ii","category","categoryIndex","categoryRangeValue","multiBrushData","_loop","idx","_i","_ii2","_dimRange","_j","_ii3","filtered","z","String","toUpperCase","currentMode","brushMode","mode","brushModes","dimensionLabels","title","flipAxisAndUpdatePCP","flip","transition","duration","animationTime","rotateLabels","delta","deltaY","dimensionTitleRotation","preventDefault","_this$2","updateAxes","position","flags","g_data","axisElement","applyAxisConfig","text","brushable","reorderable","getRange","nullValueSeparator","nullValueSeparatorPadding","autoscale","ctx","defaultScales","_extent","getTime","val","tempDate","counts","sort","tempArr","pop","categoricalRange","addBy","padding","strokeStyle","color","lineWidth","globalCompositeOperation","composite","globalAlpha","alpha","brushedColor","highlight","highlightedLineWidth","marked","markedLineWidth","shadowColor","markedShadowColor","shadowBlur","markedShadowBlur","ctrlKey","html","outerHTML","dat","parentNode","commonScale","global","t","detectDimensions","scales","bundleDimension","computeRealCentroids","row","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","protoProps","staticProps","_extends","assign","source","isValid","applyDimensionDefaults","types","detectDimensionTypes","orient","ticks","innerTickSize","outerTickSize","tickPadding","index","removeAxes","_g","axes","_this$3","axisDots","_r","r","dots","pow","beginPath","stroke","fill","axisCfg","tickValues","tickSizeInner","tickSizeOuter","tickFormat","dragging","__origin__","dx","sortDimensions","renderMarked","resize","reorder","rowdata","firstDim","sortDimensionsByRowData","reordered","highlighted","unhighlight","unmark","mark","copy","positionSortedKeys","pixelDifference","localeCompare","isBrushed","object","layer","clearRect","alphaOnBrushed","PRECISION","Matrix","elements","setElements","Vector","col","n","cols","rows","matrix","M","nj","abs","fn","els","isSameSizeAs","returnVector","modulus","canMultiplyFromLeft","sum","ni","m","isSquare","dup","np","multiplier","toRightTriangular","det","determinant","tr","rank","T","isSingular","divisor","new_element","augment","I","inverse_elements","round","matrix_rows","inspect","join","result","Diagonal","Rotation","theta","cos","sin","mod","s","RotationX","RotationY","RotationZ","Random","Zero","random","Translation","v","toUpperTriangular","trace","rk","inv","inverse","multiply","dot","vector","V","mod1","mod2","acos","angleFrom","product","B","A","obj","anchor","start","end","distanceFrom","part","line","contains","plane","R","direction","C","pointClosestTo","P","Q","computeCentroids","centroids","cx","cy","leftCentroid","clusterCentroids","get","rightCentroid","centroid","bundlingStrength","computeControlPoints","smoothness","cps","mid","diff","subtract","singleCurve","moveTo","showControlPoints","bezierCurveTo","getNullPosition","console","log","singlePath","lineTo","colorPath","_functor","pathMark","renderMarkedDefault","renderMarkedQueue","markedQueue","pathBrushed","renderBrushedDefault","renderBrushedQueue","brushedQueue","brushReset$4","brushesToKeep","toType","match","toLowerCase","adjacentPairs","arr","ret","pathHighlight","classed","pathForeground","renderDefault","default","renderDefaultQueue","foregroundQueue","queue","toTypeCoerceNumbers","parseFloat","parseInt","interactive","shadows","init","version","DefaultConfig","hideAxis","_this$4","initState","userConfig","dimensionTitles","warn","eventTypes","apply","debug","None","computeClusterCentroids","Map","clusterCounts","has","set","count","_map","_this$5","without","items","el","sideEffects","getset","side_effects","old","previous","d3_rebind","method","_rebind","bindEvents","__","ParCoords","compute_real_centroids","adjacent_pairs","__webpack_exports__","__WEBPACK_AMD_DEFINE_RESULT__","webkitRequestAnimationFrame","cancelAnimationFrame","lastTime","currTime","Date","timeToCall","setTimeout","clearTimeout","exports","module"],"mappings":"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","file":"js/chunk-e83f6f16.810f856c.js","sourcesContent":["import 'requestanimationframe';\nimport { select, event, mouse, selectAll } from 'd3-selection';\nimport { brushSelection, brushY } from 'd3-brush';\nimport { drag } from 'd3-drag';\nimport { arc } from 'd3-shape';\nimport { scaleLinear, scaleOrdinal, scalePoint, scaleTime } from 'd3-scale';\nimport { extent, min, ascending } from 'd3-array';\nimport { entries, keys } from 'd3-collection';\nimport { axisBottom, axisLeft, axisRight, axisTop } from 'd3-axis';\nimport { dispatch } from 'd3-dispatch';\n\nvar renderQueue = function renderQueue(func) {\n  var _queue = [],\n      // data to be rendered\n  _rate = 1000,\n      // number of calls per frame\n  _invalidate = function _invalidate() {},\n      // invalidate last render queue\n  _clear = function _clear() {}; // clearing function\n\n  var rq = function rq(data) {\n    if (data) rq.data(data);\n    _invalidate();\n    _clear();\n    rq.render();\n  };\n\n  rq.render = function () {\n    var valid = true;\n    _invalidate = rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      var chunk = _queue.splice(0, _rate);\n      chunk.map(func);\n      requestAnimationFrame(doFrame);\n    }\n\n    doFrame();\n  };\n\n  rq.data = function (data) {\n    _invalidate();\n    _queue = data.slice(0); // creates a copy of the data\n    return rq;\n  };\n\n  rq.add = function (data) {\n    _queue = _queue.concat(data);\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length;\n  };\n\n  // clear the canvas\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n      return rq;\n    }\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = _invalidate;\n\n  return rq;\n};\n\nvar w = function w(config) {\n  return config.width - config.margin.right - config.margin.left;\n};\n\nvar invertCategorical = function invertCategorical(selection, scale) {\n  if (selection.length === 0) {\n    return [];\n  }\n  var domain = scale.domain();\n  var range = scale.range();\n  var found = [];\n  range.forEach(function (d, i) {\n    if (d >= selection[0] && d <= selection[1]) {\n      found.push(domain[i]);\n    }\n  });\n  return found;\n};\n\nvar invertByScale = function invertByScale(selection, scale) {\n  if (scale === null) return [];\n  return typeof scale.invert === 'undefined' ? invertCategorical(selection, scale) : selection.map(function (d) {\n    return scale.invert(d);\n  });\n};\n\nvar brushExtents = function brushExtents(state, config, pc) {\n  return function (extents) {\n    var brushes = state.brushes,\n        brushNodes = state.brushNodes;\n\n\n    if (typeof extents === 'undefined') {\n      return Object.keys(config.dimensions).reduce(function (acc, cur) {\n        var brush = brushes[cur];\n        //todo: brush check\n        if (brush !== undefined && brushSelection(brushNodes[cur]) !== null) {\n          var raw = brushSelection(brushNodes[cur]);\n          var yScale = config.dimensions[cur].yscale;\n          var scaled = invertByScale(raw, yScale);\n\n          acc[cur] = {\n            extent: brush.extent(),\n            selection: {\n              raw: raw,\n              scaled: scaled\n            }\n          };\n        }\n\n        return acc;\n      }, {});\n    } else {\n      //first get all the brush selections\n      var brushSelections = {};\n      pc.g().selectAll('.brush').each(function (d) {\n        brushSelections[d] = select(this);\n      });\n\n      // loop over each dimension and update appropriately (if it was passed in through extents)\n      Object.keys(config.dimensions).forEach(function (d) {\n        if (extents[d] === undefined) {\n          return;\n        }\n\n        var brush = brushes[d];\n        if (brush !== undefined) {\n          var dim = config.dimensions[d];\n          var yExtent = extents[d].map(dim.yscale);\n\n          //update the extent\n          //sets the brushable extent to the specified array of points [[x0, y0], [x1, y1]]\n          //we actually don't need this since we are using brush.move below\n          //extents set the limits of the brush which means a user will not be able\n          //to move or drag the brush beyond the limits set by brush.extent\n          //brush.extent([[-15, yExtent[1]], [15, yExtent[0]]]);\n\n          //redraw the brush\n          //https://github.com/d3/d3-brush#brush_move\n          // For an x-brush, it must be defined as [x0, x1]; for a y-brush, it must be defined as [y0, y1].\n          brushSelections[d].call(brush).call(brush.move, yExtent.reverse());\n\n          //fire some events\n          // brush.event(brushSelections[d]);\n        }\n      });\n\n      //redraw the chart\n      pc.renderBrushed();\n\n      return pc;\n    }\n  };\n};\n\nvar _this = undefined;\n\nvar brushReset = function brushReset(state, config, pc) {\n  return function (dimension) {\n    var brushes = state.brushes;\n\n\n    if (dimension === undefined) {\n      config.brushed = false;\n      if (pc.g() !== undefined && pc.g() !== null) {\n        pc.g().selectAll('.brush').each(function (d) {\n          if (brushes[d] !== undefined) {\n            select(this).call(brushes[d].move, null);\n          }\n        });\n        pc.renderBrushed();\n      }\n    } else {\n      config.brushed = false;\n      if (pc.g() !== undefined && pc.g() !== null) {\n        pc.g().selectAll('.brush').each(function (d) {\n          if (d !== dimension) return;\n          select(this).call(brushes[d].move, null);\n          if (typeof brushes[d].type === 'function') {\n            brushes[d].event(select(this));\n          }\n        });\n        pc.renderBrushed();\n      }\n    }\n    return _this;\n  };\n};\n\n//https://github.com/d3/d3-brush/issues/10\n\n// data within extents\nvar selected = function selected(state, config, brushGroup) {\n  return function () {\n    var brushNodes = state.brushNodes;\n\n    var is_brushed = function is_brushed(p) {\n      return brushNodes[p] && brushSelection(brushNodes[p]) !== null;\n    };\n\n    var actives = Object.keys(config.dimensions).filter(is_brushed);\n    var extents = actives.map(function (p) {\n      var _brushRange = brushSelection(brushNodes[p]);\n\n      if (typeof config.dimensions[p].yscale.invert === 'function') {\n        return [config.dimensions[p].yscale.invert(_brushRange[1]), config.dimensions[p].yscale.invert(_brushRange[0])];\n      } else {\n        return _brushRange;\n      }\n    });\n    // We don't want to return the full data set when there are no axes brushed.\n    // Actually, when there are no axes brushed, by definition, no items are\n    // selected. So, let's avoid the filtering and just return false.\n    //if (actives.length === 0) return false;\n\n    // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n    if (actives.length === 0) return config.data;\n\n    // test if within range\n    var within = {\n      date: function date(d, p, dimension) {\n        if (typeof config.dimensions[p].yscale.bandwidth === 'function') {\n          // if it is ordinal\n          return extents[dimension][0] <= config.dimensions[p].yscale(d[p]) && config.dimensions[p].yscale(d[p]) <= extents[dimension][1];\n        } else {\n          return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1];\n        }\n      },\n      number: function number(d, p, dimension) {\n        if (typeof config.dimensions[p].yscale.bandwidth === 'function') {\n          // if it is ordinal\n          return extents[dimension][0] <= config.dimensions[p].yscale(d[p]) && config.dimensions[p].yscale(d[p]) <= extents[dimension][1];\n        } else {\n          return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1];\n        }\n      },\n      string: function string(d, p, dimension) {\n        return extents[dimension][0] <= config.dimensions[p].yscale(d[p]) && config.dimensions[p].yscale(d[p]) <= extents[dimension][1];\n      }\n    };\n\n    return config.data.filter(function (d) {\n      switch (brushGroup.predicate) {\n        case 'AND':\n          return actives.every(function (p, dimension) {\n            return within[config.dimensions[p].type](d, p, dimension);\n          });\n        case 'OR':\n          return actives.some(function (p, dimension) {\n            return within[config.dimensions[p].type](d, p, dimension);\n          });\n        default:\n          throw new Error('Unknown brush predicate ' + config.brushPredicate);\n      }\n    });\n  };\n};\n\nvar brushUpdated = function brushUpdated(config, pc, events, args) {\n  return function (newSelection) {\n    config.brushed = newSelection;\n    events.call('brush', pc, config.brushed, args);\n    pc.renderBrushed();\n  };\n};\n\nvar brushFor = function brushFor(state, config, pc, events, brushGroup) {\n  return function (axis, _selector) {\n    // handle hidden axes which will not be a property of dimensions\n    if (!config.dimensions.hasOwnProperty(axis)) {\n      return function () {};\n    }\n\n    var brushRangeMax = config.dimensions[axis].type === 'string' ? config.dimensions[axis].yscale.range()[config.dimensions[axis].yscale.range().length - 1] : config.dimensions[axis].yscale.range()[0];\n\n    var _brush = brushY(_selector).extent([[-15, 0], [15, brushRangeMax]]);\n\n    var convertBrushArguments = function convertBrushArguments(args) {\n      var args_array = Array.prototype.slice.call(args);\n      var axis = args_array[0];\n\n      var raw = brushSelection(args_array[2][0]) || [];\n\n      // handle hidden axes which will not have a yscale\n      var yscale = null;\n      if (config.dimensions.hasOwnProperty(axis)) {\n        yscale = config.dimensions[axis].yscale;\n      }\n\n      // ordinal scales do not have invert\n      var scaled = invertByScale(raw, yscale);\n\n      return {\n        axis: args_array[0],\n        node: args_array[2][0],\n        selection: {\n          raw: raw,\n          scaled: scaled\n        }\n      };\n    };\n\n    _brush.on('start', function () {\n      if (event.sourceEvent !== null) {\n        events.call('brushstart', pc, config.brushed, convertBrushArguments(arguments));\n        if (typeof event.sourceEvent.stopPropagation === 'function') {\n          event.sourceEvent.stopPropagation();\n        }\n      }\n    }).on('brush', function () {\n      brushUpdated(config, pc, events, convertBrushArguments(arguments))(selected(state, config, brushGroup)());\n    }).on('end', function () {\n      brushUpdated(config, pc, events)(selected(state, config, brushGroup)());\n      events.call('brushend', pc, config.brushed, convertBrushArguments(arguments));\n    });\n\n    state.brushes[axis] = _brush;\n    state.brushNodes[axis] = _selector.node();\n\n    return _brush;\n  };\n};\n\nvar install = function install(state, config, pc, events, brushGroup) {\n  return function () {\n    if (!pc.g()) {\n      pc.createAxes();\n    }\n\n    // Add and store a brush for each axis.\n    var brush = pc.g().append('svg:g').attr('class', 'brush').each(function (d) {\n      select(this).call(brushFor(state, config, pc, events, brushGroup)(d, select(this)));\n    });\n    brush.selectAll('rect').style('visibility', null).attr('x', -15).attr('width', 30);\n\n    brush.selectAll('rect.background').style('fill', 'transparent');\n\n    brush.selectAll('rect.extent').style('fill', 'rgba(255,255,255,0.25)').style('stroke', 'rgba(0,0,0,0.6)');\n\n    brush.selectAll('.resize rect').style('fill', 'rgba(0,0,0,0.1)');\n\n    pc.brushExtents = brushExtents(state, config, pc);\n    pc.brushReset = brushReset(state, config, pc);\n    return pc;\n  };\n};\n\nvar uninstall = function uninstall(state, pc) {\n  return function () {\n    if (pc.g() !== undefined && pc.g() !== null) pc.g().selectAll('.brush').remove();\n\n    state.brushes = {};\n    delete pc.brushExtents;\n    delete pc.brushReset;\n  };\n};\n\nvar install1DAxes = function install1DAxes(brushGroup, config, pc, events) {\n  var state = {\n    brushes: {},\n    brushNodes: {}\n  };\n\n  brushGroup.modes['1D-axes'] = {\n    install: install(state, config, pc, events, brushGroup),\n    uninstall: uninstall(state, pc),\n    selected: selected(state, config, brushGroup),\n    brushState: brushExtents(state, config, pc)\n  };\n};\n\nvar drawBrushes = function drawBrushes(brushes, config, pc, axis, selector) {\n  var brushSelection$$1 = selector.selectAll('.brush').data(brushes, function (d) {\n    return d.id;\n  });\n\n  brushSelection$$1.enter().insert('g', '.brush').attr('class', 'brush').attr('dimension', axis).attr('id', function (b) {\n    return 'brush-' + Object.keys(config.dimensions).indexOf(axis) + '-' + b.id;\n  }).each(function (brushObject) {\n    brushObject.brush(select(this));\n  });\n\n  brushSelection$$1.each(function (brushObject) {\n    select(this).attr('class', 'brush').selectAll('.overlay').style('pointer-events', function () {\n      var brush = brushObject.brush;\n      if (brushObject.id === brushes.length - 1 && brush !== undefined) {\n        return 'all';\n      } else {\n        return 'none';\n      }\n    });\n  });\n\n  brushSelection$$1.exit().remove();\n};\n\n// data within extents\nvar selected$1 = function selected(state, config, pc, events, brushGroup) {\n  var brushes = state.brushes;\n\n\n  var is_brushed = function is_brushed(p, pos) {\n    var axisBrushes = brushes[p];\n\n    for (var i = 0; i < axisBrushes.length; i++) {\n      var brush = document.getElementById('brush-' + pos + '-' + i);\n\n      if (brushSelection(brush) !== null) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  var actives = Object.keys(config.dimensions).filter(is_brushed);\n  var extents = actives.map(function (p) {\n    var axisBrushes = brushes[p];\n\n    return axisBrushes.map(function (d, i) {\n      return brushSelection(document.getElementById('brush-' + Object.keys(config.dimensions).indexOf(p) + '-' + i));\n    }).map(function (d, i) {\n      if (d === null || d === undefined) {\n        return null;\n      } else if (typeof config.dimensions[p].yscale.invert === 'function') {\n        return [config.dimensions[p].yscale.invert(d[1]), config.dimensions[p].yscale.invert(d[0])];\n      } else {\n        return d;\n      }\n    });\n  });\n\n  // We don't want to return the full data set when there are no axes brushed.\n  // Actually, when there are no axes brushed, by definition, no items are\n  // selected. So, let's avoid the filtering and just return false.\n  //if (actives.length === 0) return false;\n\n  // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n  if (actives.length === 0) return config.data;\n\n  // test if within range\n  var within = {\n    date: function date(d, p, i) {\n      var dimExt = extents[i];\n\n      if (typeof config.dimensions[p].yscale.bandwidth === 'function') {\n        // if it is ordinal\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = dimExt[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var e = _step.value;\n\n            if (e === null || e === undefined) {\n              continue;\n            }\n\n            if (e[0] <= config.dimensions[p].yscale(d[p]) && config.dimensions[p].yscale(d[p]) <= e[1]) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return false;\n      } else {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = dimExt[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _e = _step2.value;\n\n            if (_e === null || _e === undefined) {\n              continue;\n            }\n\n            if (_e[0] <= d[p] && d[p] <= _e[1]) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return false;\n      }\n    },\n    number: function number(d, p, i) {\n      var dimExt = extents[i];\n\n      if (typeof config.dimensions[p].yscale.bandwidth === 'function') {\n        // if it is ordinal\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = dimExt[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var e = _step3.value;\n\n            if (e === null || e === undefined) {\n              continue;\n            }\n\n            if (e[0] <= config.dimensions[p].yscale(d[p]) && config.dimensions[p].yscale(d[p]) <= e[1]) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        return false;\n      } else {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = dimExt[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _e2 = _step4.value;\n\n            if (_e2 === null || _e2 === undefined) {\n              continue;\n            }\n\n            if (_e2[0] <= d[p] && d[p] <= _e2[1]) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        return false;\n      }\n    },\n    string: function string(d, p, i) {\n      var dimExt = extents[i];\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = dimExt[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var e = _step5.value;\n\n          if (e === null || e === undefined) {\n            continue;\n          }\n\n          if (e[0] <= config.dimensions[p].yscale(d[p]) && config.dimensions[p].yscale(d[p]) <= e[1]) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return false;\n    }\n  };\n\n  return config.data.filter(function (d) {\n    switch (brushGroup.predicate) {\n      case 'AND':\n        return actives.every(function (p, i) {\n          return within[config.dimensions[p].type](d, p, i);\n        });\n      case 'OR':\n        return actives.some(function (p, i) {\n          return within[config.dimensions[p].type](d, p, i);\n        });\n      default:\n        throw new Error('Unknown brush predicate ' + config.brushPredicate);\n    }\n  });\n};\n\nvar brushUpdated$1 = function brushUpdated(config, pc, events) {\n  return function (newSelection) {\n    config.brushed = newSelection;\n    events.call('brush', pc, config.brushed);\n    pc.renderBrushed();\n  };\n};\n\nvar newBrush = function newBrush(state, config, pc, events, brushGroup) {\n  return function (axis, _selector) {\n    var brushes = state.brushes,\n        brushNodes = state.brushNodes;\n\n\n    var brushRangeMax = config.dimensions[axis].type === 'string' ? config.dimensions[axis].yscale.range()[config.dimensions[axis].yscale.range().length - 1] : config.dimensions[axis].yscale.range()[0];\n\n    var brush = brushY().extent([[-15, 0], [15, brushRangeMax]]);\n    var id = brushes[axis] ? brushes[axis].length : 0;\n    var node = 'brush-' + Object.keys(config.dimensions).indexOf(axis) + '-' + id;\n\n    if (brushes[axis]) {\n      brushes[axis].push({\n        id: id,\n        brush: brush,\n        node: node\n      });\n    } else {\n      brushes[axis] = [{ id: id, brush: brush, node: node }];\n    }\n\n    if (brushNodes[axis]) {\n      brushNodes[axis].push({ id: id, node: node });\n    } else {\n      brushNodes[axis] = [{ id: id, node: node }];\n    }\n\n    brush.on('start', function () {\n      if (event.sourceEvent !== null) {\n        events.call('brushstart', pc, config.brushed);\n        if (typeof event.sourceEvent.stopPropagation === 'function') {\n          event.sourceEvent.stopPropagation();\n        }\n      }\n    }).on('brush', function (e) {\n      // record selections\n      brushUpdated$1(config, pc, events)(selected$1(state, config, pc, events, brushGroup));\n    }).on('end', function () {\n      // Figure out if our latest brush has a selection\n      var lastBrushID = brushes[axis][brushes[axis].length - 1].id;\n      var lastBrush = document.getElementById('brush-' + Object.keys(config.dimensions).indexOf(axis) + '-' + lastBrushID);\n      var selection = brushSelection(lastBrush);\n\n      if (selection !== undefined && selection !== null && selection[0] !== selection[1]) {\n        newBrush(state, config, pc, events, brushGroup)(axis, _selector);\n\n        drawBrushes(brushes[axis], config, pc, axis, _selector);\n\n        brushUpdated$1(config, pc, events)(selected$1(state, config, pc, events, brushGroup));\n      } else {\n        if (event.sourceEvent && event.sourceEvent.toString() === '[object MouseEvent]' && event.selection === null) {\n          pc.brushReset(axis);\n        }\n      }\n\n      events.call('brushend', pc, config.brushed);\n    });\n\n    return brush;\n  };\n};\n\n/**\n *\n * extents are in format of [[2,6], [3,5]]\n *\n * * @param state\n * @param config\n * @param pc\n * @returns {Function}\n */\nvar brushExtents$1 = function brushExtents(state, config, pc, events, brushGroup) {\n  return function (extents) {\n    var brushes = state.brushes;\n\n\n    if (typeof extents === 'undefined') {\n      return Object.keys(config.dimensions).reduce(function (acc, cur, pos) {\n        var axisBrushes = brushes[cur];\n\n        if (axisBrushes === undefined || axisBrushes === null) {\n          acc[cur] = [];\n        } else {\n          acc[cur] = axisBrushes.reduce(function (d, p, i) {\n            var raw = brushSelection(document.getElementById('brush-' + pos + '-' + i));\n\n            if (raw) {\n              var yScale = config.dimensions[cur].yscale;\n              var scaled = invertByScale(raw, yScale);\n\n              d.push({\n                extent: p.brush.extent(),\n                selection: {\n                  raw: raw,\n                  scaled: scaled\n                }\n              });\n            }\n            return d;\n          }, []);\n        }\n\n        return acc;\n      }, {});\n    } else {\n      // //first get all the brush selections\n      // loop over each dimension and update appropriately (if it was passed in through extents)\n      Object.keys(config.dimensions).forEach(function (d, pos) {\n        if (extents[d] === undefined || extents[d] === null) {\n          return;\n        }\n\n        var dim = config.dimensions[d];\n\n        var yExtents = extents[d].map(function (e) {\n          return e.map(dim.yscale);\n        });\n\n        var _bs = yExtents.map(function (e, j) {\n          var _brush = newBrush(state, config, pc, events, brushGroup)(d, select('#brush-group-' + pos));\n          //update the extent\n          //sets the brushable extent to the specified array of points [[x0, y0], [x1, y1]]\n          _brush.extent([[-15, e[1]], [15, e[0]]]);\n\n          return {\n            id: j,\n            brush: _brush,\n            ext: e\n          };\n        });\n\n        brushes[d] = _bs;\n\n        drawBrushes(_bs, config, pc, d, select('#brush-group-' + pos));\n\n        //redraw the brush\n        //https://github.com/d3/d3-brush#brush_move\n        // For an x-brush, it must be defined as [x0, x1]; for a y-brush, it must be defined as [y0, y1].\n        _bs.forEach(function (f, k) {\n          select('#brush-' + pos + '-' + k).call(f.brush).call(f.brush.move, f.ext.reverse());\n        });\n      });\n\n      //redraw the chart\n      pc.renderBrushed();\n\n      return pc;\n    }\n  };\n};\n\nvar _this$1 = undefined;\n\nvar brushReset$1 = function brushReset(state, config, pc) {\n  return function (dimension) {\n    var brushes = state.brushes;\n\n\n    if (dimension === undefined) {\n      if (pc.g() !== undefined && pc.g() !== null) {\n        Object.keys(config.dimensions).forEach(function (d, pos) {\n          var axisBrush = brushes[d];\n\n          axisBrush.forEach(function (e, i) {\n            var brush = document.getElementById('brush-' + pos + '-' + i);\n            if (brushSelection(brush) !== null) {\n              pc.g().select('#brush-' + pos + '-' + i).call(e.brush.move, null);\n            }\n          });\n        });\n\n        pc.renderBrushed();\n      }\n    } else {\n      if (pc.g() !== undefined && pc.g() !== null) {\n        var axisBrush = brushes[dimension];\n        var pos = Object.keys(config.dimensions).indexOf(dimension);\n\n        axisBrush.forEach(function (e, i) {\n          var brush = document.getElementById('brush-' + pos + '-' + i);\n          if (brushSelection(brush) !== null) {\n            pc.g().select('#brush-' + pos + '-' + i).call(e.brush.move, null);\n\n            if (typeof e.event === 'function') {\n              e.event(select('#brush-' + pos + '-' + i));\n            }\n          }\n        });\n\n        pc.renderBrushed();\n      }\n    }\n    return _this$1;\n  };\n};\n\nvar brushFor$1 = function brushFor(state, config, pc, events, brushGroup) {\n  return function (axis, _selector) {\n    var brushes = state.brushes;\n\n    newBrush(state, config, pc, events, brushGroup)(axis, _selector);\n    drawBrushes(brushes[axis], config, pc, axis, _selector);\n  };\n};\n\nvar install$1 = function install(state, config, pc, events, brushGroup) {\n  return function () {\n    if (!pc.g()) {\n      pc.createAxes();\n    }\n\n    pc.g().append('svg:g').attr('id', function (d, i) {\n      return 'brush-group-' + i;\n    }).attr('class', 'brush-group').attr('dimension', function (d) {\n      return d;\n    }).each(function (d) {\n      brushFor$1(state, config, pc, events, brushGroup)(d, select(this));\n    });\n\n    pc.brushExtents = brushExtents$1(state, config, pc, events, brushGroup);\n    pc.brushReset = brushReset$1(state, config, pc);\n    return pc;\n  };\n};\n\nvar uninstall$1 = function uninstall(state, pc) {\n  return function () {\n    if (pc.g() !== undefined && pc.g() !== null) pc.g().selectAll('.brush-group').remove();\n\n    state.brushes = {};\n    delete pc.brushExtents;\n    delete pc.brushReset;\n  };\n};\n\nvar install1DMultiAxes = function install1DMultiAxes(brushGroup, config, pc, events) {\n  var state = {\n    brushes: {},\n    brushNodes: {}\n  };\n\n  brushGroup.modes['1D-axes-multi'] = {\n    install: install$1(state, config, pc, events, brushGroup),\n    uninstall: uninstall$1(state, pc),\n    selected: selected$1(state, config, brushGroup),\n    brushState: brushExtents$1(state, config, pc)\n  };\n};\n\nvar uninstall$2 = function uninstall(state, pc) {\n  return function () {\n    pc.selection.select('svg').select('g#strums').remove();\n    pc.selection.select('svg').select('rect#strum-events').remove();\n    pc.on('axesreorder.strums', undefined);\n    delete pc.brushReset;\n\n    state.strumRect = undefined;\n  };\n};\n\n// test if point falls between lines\nvar containmentTest = function containmentTest(strum, width) {\n  return function (p) {\n    var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n        p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n        m1 = 1 - width / p1[0],\n        b1 = p1[1] * (1 - m1),\n        m2 = 1 - width / p2[0],\n        b2 = p2[1] * (1 - m2);\n\n    var x = p[0],\n        y = p[1],\n        y1 = m1 * x + b1,\n        y2 = m2 * x + b2;\n\n    return y > Math.min(y1, y2) && y < Math.max(y1, y2);\n  };\n};\n\nvar crossesStrum = function crossesStrum(state, config) {\n  return function (d, id) {\n    var strum = state.strums[id],\n        test = containmentTest(strum, state.strums.width(id)),\n        d1 = strum.dims.left,\n        d2 = strum.dims.right,\n        y1 = config.dimensions[d1].yscale,\n        y2 = config.dimensions[d2].yscale,\n        point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n    return test(point);\n  };\n};\n\nvar selected$2 = function selected(brushGroup, state, config) {\n  // Get the ids of the currently active strums.\n  var ids = Object.getOwnPropertyNames(state.strums).filter(function (d) {\n    return !isNaN(d);\n  }),\n      brushed = config.data;\n\n  if (ids.length === 0) {\n    return brushed;\n  }\n\n  var crossTest = crossesStrum(state, config);\n\n  return brushed.filter(function (d) {\n    switch (brushGroup.predicate) {\n      case 'AND':\n        return ids.every(function (id) {\n          return crossTest(d, id);\n        });\n      case 'OR':\n        return ids.some(function (id) {\n          return crossTest(d, id);\n        });\n      default:\n        throw new Error('Unknown brush predicate ' + config.brushPredicate);\n    }\n  });\n};\n\nvar removeStrum = function removeStrum(state, pc) {\n  var strum = state.strums[state.strums.active],\n      svg = pc.selection.select('svg').select('g#strums');\n\n  delete state.strums[state.strums.active];\n  svg.selectAll('line#strum-' + strum.dims.i).remove();\n  svg.selectAll('circle#strum-' + strum.dims.i).remove();\n};\n\nvar onDragEnd = function onDragEnd(brushGroup, state, config, pc, events) {\n  return function () {\n    var strum = state.strums[state.strums.active];\n\n    // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n    // considered a drag without move. So we have to deal with that case\n    if (strum && strum.p1[0] === strum.p2[0] && strum.p1[1] === strum.p2[1]) {\n      removeStrum(state, pc);\n    }\n\n    var brushed = selected$2(brushGroup, state, config);\n    state.strums.active = undefined;\n    config.brushed = brushed;\n    pc.renderBrushed();\n    events.call('brushend', pc, config.brushed);\n  };\n};\n\nvar drawStrum = function drawStrum(brushGroup, state, config, pc, events, strum, activePoint) {\n  var _svg = pc.selection.select('svg').select('g#strums'),\n      id = strum.dims.i,\n      points = [strum.p1, strum.p2],\n      _line = _svg.selectAll('line#strum-' + id).data([strum]),\n      circles = _svg.selectAll('circle#strum-' + id).data(points),\n      _drag = drag();\n\n  _line.enter().append('line').attr('id', 'strum-' + id).attr('class', 'strum');\n\n  _line.attr('x1', function (d) {\n    return d.p1[0];\n  }).attr('y1', function (d) {\n    return d.p1[1];\n  }).attr('x2', function (d) {\n    return d.p2[0];\n  }).attr('y2', function (d) {\n    return d.p2[1];\n  }).attr('stroke', 'black').attr('stroke-width', 2);\n\n  _drag.on('drag', function (d, i) {\n    var ev = event;\n    i = i + 1;\n    strum['p' + i][0] = Math.min(Math.max(strum.minX + 1, ev.x), strum.maxX);\n    strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n    drawStrum(brushGroup, state, config, pc, events, strum, i - 1);\n  }).on('end', onDragEnd(brushGroup, state, config, pc, events));\n\n  circles.enter().append('circle').attr('id', 'strum-' + id).attr('class', 'strum');\n\n  circles.attr('cx', function (d) {\n    return d[0];\n  }).attr('cy', function (d) {\n    return d[1];\n  }).attr('r', 5).style('opacity', function (d, i) {\n    return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n  }).on('mouseover', function () {\n    select(this).style('opacity', 0.8);\n  }).on('mouseout', function () {\n    select(this).style('opacity', 0);\n  }).call(_drag);\n};\n\nvar onDrag = function onDrag(brushGroup, state, config, pc, events) {\n  return function () {\n    var ev = event,\n        strum = state.strums[state.strums.active];\n\n    // Make sure that the point is within the bounds\n    strum.p2[0] = Math.min(Math.max(strum.minX + 1, ev.x - config.margin.left), strum.maxX);\n    strum.p2[1] = Math.min(Math.max(strum.minY, ev.y - config.margin.top), strum.maxY);\n\n    drawStrum(brushGroup, state, config, pc, events, strum, 1);\n  };\n};\n\nvar h = function h(config) {\n  return config.height - config.margin.top - config.margin.bottom;\n};\n\nvar dimensionsForPoint = function dimensionsForPoint(config, pc, xscale, p) {\n  var dims = { i: -1, left: undefined, right: undefined };\n  Object.keys(config.dimensions).some(function (dim, i) {\n    if (xscale(dim) < p[0]) {\n      dims.i = i;\n      dims.left = dim;\n      dims.right = Object.keys(config.dimensions)[pc.getOrderedDimensionKeys().indexOf(dim) + 1];\n      return false;\n    }\n    return true;\n  });\n\n  if (dims.left === undefined) {\n    // Event on the left side of the first axis.\n    dims.i = 0;\n    dims.left = pc.getOrderedDimensionKeys()[0];\n    dims.right = pc.getOrderedDimensionKeys()[1];\n  } else if (dims.right === undefined) {\n    // Event on the right side of the last axis\n    dims.i = Object.keys(config.dimensions).length - 1;\n    dims.right = dims.left;\n    dims.left = pc.getOrderedDimensionKeys()[Object.keys(config.dimensions).length - 2];\n  }\n\n  return dims;\n};\n\n// First we need to determine between which two axes the sturm was started.\n// This will determine the freedom of movement, because a strum can\n// logically only happen between two axes, so no movement outside these axes\n// should be allowed.\nvar onDragStart = function onDragStart(state, config, pc, xscale) {\n  return function () {\n    var p = mouse(state.strumRect.node());\n\n    p[0] = p[0] - config.margin.left;\n    p[1] = p[1] - config.margin.top;\n\n    var dims = dimensionsForPoint(config, pc, xscale, p);\n    var strum = {\n      p1: p,\n      dims: dims,\n      minX: xscale(dims.left),\n      maxX: xscale(dims.right),\n      minY: 0,\n      maxY: h(config)\n    };\n\n    // Make sure that the point is within the bounds\n    strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n    strum.p2 = strum.p1.slice();\n\n    state.strums[dims.i] = strum;\n    state.strums.active = dims.i;\n  };\n};\n\nvar brushReset$2 = function brushReset(brushGroup, state, config, pc, events) {\n  return function () {\n    var ids = Object.getOwnPropertyNames(state.strums).filter(function (d) {\n      return !isNaN(d);\n    });\n\n    ids.forEach(function (d) {\n      state.strums.active = d;\n      removeStrum(state, pc);\n    });\n    onDragEnd(brushGroup, state, config, pc, events)();\n  };\n};\n\n// Checks if the first dimension is directly left of the second dimension.\nvar consecutive = function consecutive(dimensions) {\n  return function (first, second) {\n    var keys$$1 = Object.keys(dimensions);\n\n    return keys$$1.some(function (d, i) {\n      return d === first ? i + i < keys$$1.length && dimensions[i + 1] === second : false;\n    });\n  };\n};\n\nvar install$2 = function install(brushGroup, state, config, pc, events, xscale) {\n  return function () {\n    if (pc.g() === undefined || pc.g() === null) {\n      pc.createAxes();\n    }\n\n    var _drag = drag();\n\n    // Map of current strums. Strums are stored per segment of the PC. A segment,\n    // being the area between two axes. The left most area is indexed at 0.\n    state.strums.active = undefined;\n    // Returns the width of the PC segment where currently a strum is being\n    // placed. NOTE: even though they are evenly spaced in our current\n    // implementation, we keep for when non-even spaced segments are supported as\n    // well.\n    state.strums.width = function (id) {\n      return state.strums[id] === undefined ? undefined : state.strums[id].maxX - state.strums[id].minX;\n    };\n\n    pc.on('axesreorder.strums', function () {\n      var ids = Object.getOwnPropertyNames(state.strums).filter(function (d) {\n        return !isNaN(d);\n      });\n\n      if (ids.length > 0) {\n        // We have some strums, which might need to be removed.\n        ids.forEach(function (d) {\n          var dims = state.strums[d].dims;\n          state.strums.active = d;\n          // If the two dimensions of the current strum are not next to each other\n          // any more, than we'll need to remove the strum. Otherwise we keep it.\n          if (!consecutive(config.dimensions)(dims.left, dims.right)) {\n            removeStrum(state, pc);\n          }\n        });\n        onDragEnd(brushGroup, state, config, pc, events)();\n      }\n    });\n\n    // Add a new svg group in which we draw the strums.\n    pc.selection.select('svg').append('g').attr('id', 'strums').attr('transform', 'translate(' + config.margin.left + ',' + config.margin.top + ')');\n\n    // Install the required brushReset function\n    pc.brushReset = brushReset$2(brushGroup, state, config, pc, events);\n\n    _drag.on('start', onDragStart(state, config, pc, xscale)).on('drag', onDrag(brushGroup, state, config, pc, events)).on('end', onDragEnd(brushGroup, state, config, pc, events));\n\n    // NOTE: The styling needs to be done here and not in the css. This is because\n    //       for 1D brushing, the canvas layers should not listen to\n    //       pointer-events._.\n    state.strumRect = pc.selection.select('svg').insert('rect', 'g#strums').attr('id', 'strum-events').attr('x', config.margin.left).attr('y', config.margin.top).attr('width', w(config)).attr('height', h(config) + 2).style('opacity', 0).call(_drag);\n  };\n};\n\nvar install2DStrums = function install2DStrums(brushGroup, config, pc, events, xscale) {\n  var state = {\n    strums: {},\n    strumRect: {}\n  };\n\n  brushGroup.modes['2D-strums'] = {\n    install: install$2(brushGroup, state, config, pc, events, xscale),\n    uninstall: uninstall$2(state, pc),\n    selected: selected$2(brushGroup, state, config),\n    brushState: function brushState() {\n      return state.strums;\n    }\n  };\n};\n\nvar uninstall$3 = function uninstall(state, pc) {\n  return function () {\n    pc.selection.select('svg').select('g#arcs').remove();\n    pc.selection.select('svg').select('rect#arc-events').remove();\n    pc.on('axesreorder.arcs', undefined);\n\n    delete pc.brushReset;\n\n    state.strumRect = undefined;\n  };\n};\n\nvar hypothenuse = function hypothenuse(a, b) {\n  return Math.sqrt(a * a + b * b);\n};\n\n// [0, 2*PI] -> [-PI/2, PI/2]\nvar signedAngle = function signedAngle(angle) {\n  return angle > Math.PI ? 1.5 * Math.PI - angle : 0.5 * Math.PI - angle;\n};\n\n/**\n * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n * However, one can only select lines from 0 to PI, so we compute the\n * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n * are 12 and 6 o'clock respectively.\n */\nvar containmentTest$1 = function containmentTest(arc$$1) {\n  return function (a) {\n    var startAngle = signedAngle(arc$$1.startAngle);\n    var endAngle = signedAngle(arc$$1.endAngle);\n\n    if (startAngle > endAngle) {\n      var tmp = startAngle;\n      startAngle = endAngle;\n      endAngle = tmp;\n    }\n\n    // test if segment angle is contained in angle interval\n    return a >= startAngle && a <= endAngle;\n  };\n};\n\nvar crossesStrum$1 = function crossesStrum(state, config) {\n  return function (d, id) {\n    var arc$$1 = state.arcs[id],\n        test = containmentTest$1(arc$$1),\n        d1 = arc$$1.dims.left,\n        d2 = arc$$1.dims.right,\n        y1 = config.dimensions[d1].yscale,\n        y2 = config.dimensions[d2].yscale,\n        a = state.arcs.width(id),\n        b = y1(d[d1]) - y2(d[d2]),\n        c = hypothenuse(a, b),\n        angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n    return test(angle);\n  };\n};\n\nvar selected$3 = function selected(brushGroup, state, config) {\n  var ids = Object.getOwnPropertyNames(state.arcs).filter(function (d) {\n    return !isNaN(d);\n  });\n  var brushed = config.data;\n\n  if (ids.length === 0) {\n    return brushed;\n  }\n\n  var crossTest = crossesStrum$1(state, config);\n\n  return brushed.filter(function (d) {\n    switch (brushGroup.predicate) {\n      case 'AND':\n        return ids.every(function (id) {\n          return crossTest(d, id);\n        });\n      case 'OR':\n        return ids.some(function (id) {\n          return crossTest(d, id);\n        });\n      default:\n        throw new Error('Unknown brush predicate ' + config.brushPredicate);\n    }\n  });\n};\n\nvar removeStrum$1 = function removeStrum(state, pc) {\n  var arc$$1 = state.arcs[state.arcs.active],\n      svg = pc.selection.select('svg').select('g#arcs');\n\n  delete state.arcs[state.arcs.active];\n  state.arcs.active = undefined;\n  svg.selectAll('line#arc-' + arc$$1.dims.i).remove();\n  svg.selectAll('circle#arc-' + arc$$1.dims.i).remove();\n  svg.selectAll('path#arc-' + arc$$1.dims.i).remove();\n};\n\nvar onDragEnd$1 = function onDragEnd(brushGroup, state, config, pc, events) {\n  return function () {\n    var arc$$1 = state.arcs[state.arcs.active];\n\n    // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n    // considered a drag without move. So we have to deal with that case\n    if (arc$$1 && arc$$1.p1[0] === arc$$1.p2[0] && arc$$1.p1[1] === arc$$1.p2[1]) {\n      removeStrum$1(state, pc);\n    }\n\n    if (arc$$1) {\n      var angle = state.arcs.startAngle(state.arcs.active);\n\n      arc$$1.startAngle = angle;\n      arc$$1.endAngle = angle;\n      arc$$1.arc.outerRadius(state.arcs.length(state.arcs.active)).startAngle(angle).endAngle(angle);\n    }\n\n    state.arcs.active = undefined;\n    config.brushed = selected$3(brushGroup, state, config);\n    pc.renderBrushed();\n    events.call('brushend', pc, config.brushed);\n  };\n};\n\nvar drawStrum$1 = function drawStrum(brushGroup, state, config, pc, events, arc$$1, activePoint) {\n  var svg = pc.selection.select('svg').select('g#arcs'),\n      id = arc$$1.dims.i,\n      points = [arc$$1.p2, arc$$1.p3],\n      _line = svg.selectAll('line#arc-' + id).data([{ p1: arc$$1.p1, p2: arc$$1.p2 }, { p1: arc$$1.p1, p2: arc$$1.p3 }]),\n      circles = svg.selectAll('circle#arc-' + id).data(points),\n      _drag = drag(),\n      _path = svg.selectAll('path#arc-' + id).data([arc$$1]);\n\n  _path.enter().append('path').attr('id', 'arc-' + id).attr('class', 'arc').style('fill', 'orange').style('opacity', 0.5);\n\n  _path.attr('d', arc$$1.arc).attr('transform', 'translate(' + arc$$1.p1[0] + ',' + arc$$1.p1[1] + ')');\n\n  _line.enter().append('line').attr('id', 'arc-' + id).attr('class', 'arc');\n\n  _line.attr('x1', function (d) {\n    return d.p1[0];\n  }).attr('y1', function (d) {\n    return d.p1[1];\n  }).attr('x2', function (d) {\n    return d.p2[0];\n  }).attr('y2', function (d) {\n    return d.p2[1];\n  }).attr('stroke', 'black').attr('stroke-width', 2);\n\n  _drag.on('drag', function (d, i) {\n    var ev = event;\n    i = i + 2;\n\n    arc$$1['p' + i][0] = Math.min(Math.max(arc$$1.minX + 1, ev.x), arc$$1.maxX);\n    arc$$1['p' + i][1] = Math.min(Math.max(arc$$1.minY, ev.y), arc$$1.maxY);\n\n    var angle = i === 3 ? state.arcs.startAngle(id) : state.arcs.endAngle(id);\n\n    if (arc$$1.startAngle < Math.PI && arc$$1.endAngle < Math.PI && angle < Math.PI || arc$$1.startAngle >= Math.PI && arc$$1.endAngle >= Math.PI && angle >= Math.PI) {\n      if (i === 2) {\n        arc$$1.endAngle = angle;\n        arc$$1.arc.endAngle(angle);\n      } else if (i === 3) {\n        arc$$1.startAngle = angle;\n        arc$$1.arc.startAngle(angle);\n      }\n    }\n\n    drawStrum(brushGroup, state, config, pc, events, arc$$1, i - 2);\n  }).on('end', onDragEnd$1(brushGroup, state, config, pc, events));\n\n  circles.enter().append('circle').attr('id', 'arc-' + id).attr('class', 'arc');\n\n  circles.attr('cx', function (d) {\n    return d[0];\n  }).attr('cy', function (d) {\n    return d[1];\n  }).attr('r', 5).style('opacity', function (d, i) {\n    return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n  }).on('mouseover', function () {\n    select(this).style('opacity', 0.8);\n  }).on('mouseout', function () {\n    select(this).style('opacity', 0);\n  }).call(_drag);\n};\n\nvar onDrag$1 = function onDrag(brushGroup, state, config, pc, events) {\n  return function () {\n    var ev = event,\n        arc$$1 = state.arcs[state.arcs.active];\n\n    // Make sure that the point is within the bounds\n    arc$$1.p2[0] = Math.min(Math.max(arc$$1.minX + 1, ev.x - config.margin.left), arc$$1.maxX);\n    arc$$1.p2[1] = Math.min(Math.max(arc$$1.minY, ev.y - config.margin.top), arc$$1.maxY);\n    arc$$1.p3 = arc$$1.p2.slice();\n    drawStrum$1(brushGroup, state, config, pc, events, arc$$1, 1);\n  };\n};\n\n// First we need to determine between which two axes the arc was started.\n// This will determine the freedom of movement, because a arc can\n// logically only happen between two axes, so no movement outside these axes\n// should be allowed.\nvar onDragStart$1 = function onDragStart(state, config, pc, xscale) {\n  return function () {\n    var p = mouse(state.strumRect.node());\n\n    p[0] = p[0] - config.margin.left;\n    p[1] = p[1] - config.margin.top;\n\n    var dims = dimensionsForPoint(config, pc, xscale, p);\n    var arc$$1 = {\n      p1: p,\n      dims: dims,\n      minX: xscale(dims.left),\n      maxX: xscale(dims.right),\n      minY: 0,\n      maxY: h(config),\n      startAngle: undefined,\n      endAngle: undefined,\n      arc: arc().innerRadius(0)\n    };\n\n    // Make sure that the point is within the bounds\n    arc$$1.p1[0] = Math.min(Math.max(arc$$1.minX, p[0]), arc$$1.maxX);\n    arc$$1.p2 = arc$$1.p1.slice();\n    arc$$1.p3 = arc$$1.p1.slice();\n\n    state.arcs[dims.i] = arc$$1;\n    state.arcs.active = dims.i;\n  };\n};\n\nvar brushReset$3 = function brushReset(brushGroup, state, config, pc, events) {\n  return function () {\n    var ids = Object.getOwnPropertyNames(state.arcs).filter(function (d) {\n      return !isNaN(d);\n    });\n\n    ids.forEach(function (d) {\n      state.arcs.active = d;\n      removeStrum$1(state, pc);\n    });\n    onDragEnd$1(brushGroup, state, config, pc, events)();\n  };\n};\n\n// returns angles in [-PI/2, PI/2]\nvar angle = function angle(p1, p2) {\n  var a = p1[0] - p2[0],\n      b = p1[1] - p2[1],\n      c = hypothenuse(a, b);\n\n  return Math.asin(b / c);\n};\n\nvar endAngle = function endAngle(state) {\n  return function (id) {\n    var arc$$1 = state.arcs[id];\n    if (arc$$1 === undefined) {\n      return undefined;\n    }\n    var sAngle = angle(arc$$1.p1, arc$$1.p2),\n        uAngle = -sAngle + Math.PI / 2;\n\n    if (arc$$1.p1[0] > arc$$1.p2[0]) {\n      uAngle = 2 * Math.PI - uAngle;\n    }\n\n    return uAngle;\n  };\n};\n\nvar startAngle = function startAngle(state) {\n  return function (id) {\n    var arc$$1 = state.arcs[id];\n    if (arc$$1 === undefined) {\n      return undefined;\n    }\n\n    var sAngle = angle(arc$$1.p1, arc$$1.p3),\n        uAngle = -sAngle + Math.PI / 2;\n\n    if (arc$$1.p1[0] > arc$$1.p3[0]) {\n      uAngle = 2 * Math.PI - uAngle;\n    }\n\n    return uAngle;\n  };\n};\n\nvar length = function length(state) {\n  return function (id) {\n    var arc$$1 = state.arcs[id];\n\n    if (arc$$1 === undefined) {\n      return undefined;\n    }\n\n    var a = arc$$1.p1[0] - arc$$1.p2[0],\n        b = arc$$1.p1[1] - arc$$1.p2[1];\n\n    return hypothenuse(a, b);\n  };\n};\n\nvar install$3 = function install(brushGroup, state, config, pc, events, xscale) {\n  return function () {\n    if (!pc.g()) {\n      pc.createAxes();\n    }\n\n    var _drag = drag();\n\n    // Map of current arcs. arcs are stored per segment of the PC. A segment,\n    // being the area between two axes. The left most area is indexed at 0.\n    state.arcs.active = undefined;\n    // Returns the width of the PC segment where currently a arc is being\n    // placed. NOTE: even though they are evenly spaced in our current\n    // implementation, we keep for when non-even spaced segments are supported as\n    // well.\n    state.arcs.width = function (id) {\n      var arc$$1 = state.arcs[id];\n      return arc$$1 === undefined ? undefined : arc$$1.maxX - arc$$1.minX;\n    };\n\n    // returns angles in [0, 2 * PI]\n    state.arcs.endAngle = endAngle(state);\n    state.arcs.startAngle = startAngle(state);\n    state.arcs.length = length(state);\n\n    pc.on('axesreorder.arcs', function () {\n      var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n        return !isNaN(d);\n      });\n\n      if (ids.length > 0) {\n        // We have some arcs, which might need to be removed.\n        ids.forEach(function (d) {\n          var dims = arcs[d].dims;\n          state.arcs.active = d;\n          // If the two dimensions of the current arc are not next to each other\n          // any more, than we'll need to remove the arc. Otherwise we keep it.\n          if (!consecutive(dims)(dims.left, dims.right)) {\n            removeStrum$1(state, pc);\n          }\n        });\n        onDragEnd$1(brushGroup, state, config, pc, events)();\n      }\n    });\n\n    // Add a new svg group in which we draw the arcs.\n    pc.selection.select('svg').append('g').attr('id', 'arcs').attr('transform', 'translate(' + config.margin.left + ',' + config.margin.top + ')');\n\n    // Install the required brushReset function\n    pc.brushReset = brushReset$3(brushGroup, state, config, pc, events);\n\n    _drag.on('start', onDragStart$1(state, config, pc, xscale)).on('drag', onDrag$1(brushGroup, state, config, pc, events)).on('end', onDragEnd$1(brushGroup, state, config, pc, events));\n\n    // NOTE: The styling needs to be done here and not in the css. This is because\n    //       for 1D brushing, the canvas layers should not listen to\n    //       pointer-events._.\n    state.strumRect = pc.selection.select('svg').insert('rect', 'g#arcs').attr('id', 'arc-events').attr('x', config.margin.left).attr('y', config.margin.top).attr('width', w(config)).attr('height', h(config) + 2).style('opacity', 0).call(_drag);\n  };\n};\n\nvar installAngularBrush = function installAngularBrush(brushGroup, config, pc, events, xscale) {\n  var state = {\n    arcs: {},\n    strumRect: {}\n  };\n\n  brushGroup.modes['angular'] = {\n    install: install$3(brushGroup, state, config, pc, events, xscale),\n    uninstall: uninstall$3(state, pc),\n    selected: selected$3(brushGroup, state, config),\n    brushState: function brushState() {\n      return state.arcs;\n    }\n  };\n};\n\n// calculate 2d intersection of line a->b with line c->d\n// points are objects with x and y properties\nvar intersection = function intersection(a, b, c, d) {\n  return {\n    x: ((a.x * b.y - a.y * b.x) * (c.x - d.x) - (a.x - b.x) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n    y: ((a.x * b.y - a.y * b.x) * (c.y - d.y) - (a.y - b.y) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x))\n  };\n};\n\n// Merges the canvases and SVG elements into one canvas element which is then passed into the callback\n// (so you can choose to save it to disk, etc.)\nvar mergeParcoords = function mergeParcoords(pc) {\n  return function (callback) {\n    // Retina display, etc.\n    var devicePixelRatio = window.devicePixelRatio || 1;\n\n    // Create a canvas element to store the merged canvases\n    var mergedCanvas = document.createElement('canvas');\n\n    var foregroundCanvas = pc.canvas.foreground;\n    // We will need to adjust for canvas margins to align the svg and canvas\n    var canvasMarginLeft = Number(foregroundCanvas.style.marginLeft.replace('px', ''));\n\n    var textTopAdjust = 15;\n    var canvasMarginTop = Number(foregroundCanvas.style.marginTop.replace('px', '')) + textTopAdjust;\n    var width = (foregroundCanvas.clientWidth + canvasMarginLeft) * devicePixelRatio;\n    var height = (foregroundCanvas.clientHeight + canvasMarginTop) * devicePixelRatio;\n    mergedCanvas.width = width + 50; // pad so that svg labels at right will not get cut off\n    mergedCanvas.height = height + 30; // pad so that svg labels at bottom will not get cut off\n    mergedCanvas.style.width = mergedCanvas.width / devicePixelRatio + 'px';\n    mergedCanvas.style.height = mergedCanvas.height / devicePixelRatio + 'px';\n\n    // Give the canvas a white background\n    var context = mergedCanvas.getContext('2d');\n    context.fillStyle = '#ffffff';\n    context.fillRect(0, 0, mergedCanvas.width, mergedCanvas.height);\n\n    // Merge all the canvases\n    for (var key in pc.canvas) {\n      context.drawImage(pc.canvas[key], canvasMarginLeft * devicePixelRatio, canvasMarginTop * devicePixelRatio, width - canvasMarginLeft * devicePixelRatio, height - canvasMarginTop * devicePixelRatio);\n    }\n\n    // Add SVG elements to canvas\n    var DOMURL = window.URL || window.webkitURL || window;\n    var serializer = new XMLSerializer();\n    // axis labels are translated (0,-5) so we will clone the svg\n    //   and translate down so the labels are drawn on the canvas\n    var svgNodeCopy = pc.selection.select('svg').node().cloneNode(true);\n    svgNodeCopy.setAttribute('transform', 'translate(0,' + textTopAdjust + ')');\n    svgNodeCopy.setAttribute('height', svgNodeCopy.getAttribute('height') + textTopAdjust);\n    // text will need fill attribute since css styles will not get picked up\n    //   this is not sophisticated since it doesn't look up css styles\n    //   if the user changes\n    select(svgNodeCopy).selectAll('text').attr('fill', 'black');\n    var svgStr = serializer.serializeToString(svgNodeCopy);\n\n    // Create a Data URI.\n    var src = 'data:image/svg+xml;base64,' + window.btoa(svgStr);\n    var img = new Image();\n    img.onload = function () {\n      context.drawImage(img, 0, 0, img.width * devicePixelRatio, img.height * devicePixelRatio);\n      if (typeof callback === 'function') {\n        callback(mergedCanvas);\n      }\n    };\n    img.src = src;\n  };\n};\n\nvar selected$4 = function selected(config, pc) {\n  return function () {\n    var actives = [];\n    var extents = [];\n    var ranges = {};\n    //get brush selections from each node, convert to actual values\n    //invert order of values in array to comply with the parcoords architecture\n    if (config.brushes.length === 0) {\n      var nodes = pc.g().selectAll('.brush').nodes();\n      for (var k = 0; k < nodes.length; k++) {\n        if (brushSelection(nodes[k]) !== null) {\n          actives.push(nodes[k].__data__);\n          var values = [];\n          var ranger = brushSelection(nodes[k]);\n          if (typeof config.dimensions[nodes[k].__data__].yscale.domain()[0] === 'number') {\n            for (var i = 0; i < ranger.length; i++) {\n              if (actives.includes(nodes[k].__data__) && config.flipAxes.includes(nodes[k].__data__)) {\n                values.push(config.dimensions[nodes[k].__data__].yscale.invert(ranger[i]));\n              } else if (config.dimensions[nodes[k].__data__].yscale() !== 1) {\n                values.unshift(config.dimensions[nodes[k].__data__].yscale.invert(ranger[i]));\n              }\n            }\n            extents.push(values);\n            for (var ii = 0; ii < extents.length; ii++) {\n              if (extents[ii].length === 0) {\n                extents[ii] = [1, 1];\n              }\n            }\n          } else {\n            ranges[nodes[k].__data__] = brushSelection(nodes[k]);\n            var dimRange = config.dimensions[nodes[k].__data__].yscale.range();\n            var dimDomain = config.dimensions[nodes[k].__data__].yscale.domain();\n            for (var j = 0; j < dimRange.length; j++) {\n              if (dimRange[j] >= ranger[0] && dimRange[j] <= ranger[1] && actives.includes(nodes[k].__data__) && config.flipAxes.includes(nodes[k].__data__)) {\n                values.push(dimRange[j]);\n              } else if (dimRange[j] >= ranger[0] && dimRange[j] <= ranger[1]) {\n                values.unshift(dimRange[j]);\n              }\n            }\n            extents.push(values);\n            for (var _ii = 0; _ii < extents.length; _ii++) {\n              if (extents[_ii].length === 0) {\n                extents[_ii] = [1, 1];\n              }\n            }\n          }\n        }\n      }\n      // test if within range\n      var within = {\n        date: function date(d, p, dimension) {\n          var category = d[p];\n          var categoryIndex = config.dimensions[p].yscale.domain().indexOf(category);\n          var categoryRangeValue = config.dimensions[p].yscale.range()[categoryIndex];\n          return categoryRangeValue >= ranges[p][0] && categoryRangeValue <= ranges[p][1];\n        },\n        number: function number(d, p, dimension) {\n          return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1];\n        },\n        string: function string(d, p, dimension) {\n          var category = d[p];\n          var categoryIndex = config.dimensions[p].yscale.domain().indexOf(category);\n          var categoryRangeValue = config.dimensions[p].yscale.range()[categoryIndex];\n          return categoryRangeValue >= ranges[p][0] && categoryRangeValue <= ranges[p][1];\n        }\n      };\n      return config.data.filter(function (d) {\n        return actives.every(function (p, dimension) {\n          return within[config.dimensions[p].type](d, p, dimension);\n        });\n      });\n    } else {\n      // need to get data from each brush instead of each axis\n      // first must find active axes by iterating through all brushes\n      // then go through similiar process as above.\n      var multiBrushData = [];\n\n      var _loop = function _loop(idx) {\n        var brush = config.brushes[idx];\n        var values = [];\n        var ranger = brush.extent;\n        var actives = [brush.data];\n        if (typeof config.dimensions[brush.data].yscale.domain()[0] === 'number') {\n          for (var _i = 0; _i < ranger.length; _i++) {\n            if (actives.includes(brush.data) && config.flipAxes.includes(brush.data)) {\n              values.push(config.dimensions[brush.data].yscale.invert(ranger[_i]));\n            } else if (config.dimensions[brush.data].yscale() !== 1) {\n              values.unshift(config.dimensions[brush.data].yscale.invert(ranger[_i]));\n            }\n          }\n          extents.push(values);\n          for (var _ii2 = 0; _ii2 < extents.length; _ii2++) {\n            if (extents[_ii2].length === 0) {\n              extents[_ii2] = [1, 1];\n            }\n          }\n        } else {\n          ranges[brush.data] = brush.extent;\n          var _dimRange = config.dimensions[brush.data].yscale.range();\n          var _dimDomain = config.dimensions[brush.data].yscale.domain();\n          for (var _j = 0; _j < _dimRange.length; _j++) {\n            if (_dimRange[_j] >= ranger[0] && _dimRange[_j] <= ranger[1] && actives.includes(brush.data) && config.flipAxes.includes(brush.data)) {\n              values.push(_dimRange[_j]);\n            } else if (_dimRange[_j] >= ranger[0] && _dimRange[_j] <= ranger[1]) {\n              values.unshift(_dimRange[_j]);\n            }\n          }\n          extents.push(values);\n          for (var _ii3 = 0; _ii3 < extents.length; _ii3++) {\n            if (extents[_ii3].length === 0) {\n              extents[_ii3] = [1, 1];\n            }\n          }\n        }\n        var within = {\n          date: function date(d, p, dimension) {\n            var category = d[p];\n            var categoryIndex = config.dimensions[p].yscale.domain().indexOf(category);\n            var categoryRangeValue = config.dimensions[p].yscale.range()[categoryIndex];\n            return categoryRangeValue >= ranges[p][0] && categoryRangeValue <= ranges[p][1];\n          },\n          number: function number(d, p, dimension) {\n            return extents[idx][0] <= d[p] && d[p] <= extents[idx][1];\n          },\n          string: function string(d, p, dimension) {\n            var category = d[p];\n            var categoryIndex = config.dimensions[p].yscale.domain().indexOf(category);\n            var categoryRangeValue = config.dimensions[p].yscale.range()[categoryIndex];\n            return categoryRangeValue >= ranges[p][0] && categoryRangeValue <= ranges[p][1];\n          }\n        };\n\n        // filter data, but instead of returning it now,\n        // put it into multiBrush data which is returned after\n        // all brushes are iterated through.\n        var filtered = config.data.filter(function (d) {\n          return actives.every(function (p, dimension) {\n            return within[config.dimensions[p].type](d, p, dimension);\n          });\n        });\n        for (var z = 0; z < filtered.length; z++) {\n          multiBrushData.push(filtered[z]);\n        }\n        actives = [];\n        ranges = {};\n      };\n\n      for (var idx = 0; idx < config.brushes.length; idx++) {\n        _loop(idx);\n      }\n      return multiBrushData;\n    }\n  };\n};\n\nvar brushPredicate = function brushPredicate(brushGroup, config, pc) {\n  return function () {\n    var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (predicate === null) {\n      return brushGroup.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw new Error('Invalid predicate ' + predicate);\n    }\n\n    brushGroup.predicate = predicate;\n    config.brushed = brushGroup.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  };\n};\n\nvar brushMode = function brushMode(brushGroup, config, pc) {\n  return function () {\n    var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (mode === null) {\n      return brushGroup.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw new Error('pc.brushmode: Unsupported brush mode: ' + mode);\n    }\n\n    // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n    if (mode !== brushGroup.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brushGroup.mode !== 'None') {\n        pc.brushReset();\n      }\n\n      // Next, we need to 'uninstall' the current brushMode.\n      brushGroup.modes[brushGroup.mode].uninstall(pc);\n      // Finally, we can install the requested one.\n      brushGroup.mode = mode;\n      brushGroup.modes[brushGroup.mode].install();\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate(brushGroup, config, pc);\n      }\n    }\n\n    return pc;\n  };\n};\n\n/**\n * dimension display names\n *\n * @param config\n * @param d\n * @returns {*}\n */\nvar dimensionLabels = function dimensionLabels(config) {\n  return function (d) {\n    return config.dimensions[d].title ? config.dimensions[d].title : d;\n  };\n};\n\nvar flipAxisAndUpdatePCP = function flipAxisAndUpdatePCP(config, pc, axis) {\n  return function (dimension) {\n    pc.flip(dimension);\n    pc.brushReset(dimension);\n\n    // select(this.parentElement)\n    pc.selection.select('svg').selectAll('g.axis').filter(function (d) {\n      return d === dimension;\n    }).transition().duration(config.animationTime).call(axis.scale(config.dimensions[dimension].yscale));\n    pc.render();\n  };\n};\n\nvar rotateLabels = function rotateLabels(config, pc) {\n  if (!config.rotateLabels) return;\n\n  var delta = event.deltaY;\n  delta = delta < 0 ? -5 : delta;\n  delta = delta > 0 ? 5 : delta;\n\n  config.dimensionTitleRotation += delta;\n  pc.svg.selectAll('text.label').attr('transform', 'translate(0,-5) rotate(' + config.dimensionTitleRotation + ')');\n  event.preventDefault();\n};\n\nvar _this$2 = undefined;\n\nvar updateAxes = function updateAxes(config, pc, position, axis, flags) {\n  return function () {\n    var animationTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (animationTime === null) {\n      animationTime = config.animationTime;\n    }\n\n    var g_data = pc.svg.selectAll('.dimension').data(pc.getOrderedDimensionKeys());\n    // Enter\n    g_data.enter().append('svg:g').attr('class', 'dimension').attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).style('opacity', 0).append('svg:g').attr('class', 'axis').attr('transform', 'translate(0,0)').each(function (d) {\n      var axisElement = select(this).call(pc.applyAxisConfig(axis, config.dimensions[d]));\n\n      axisElement.selectAll('path').style('fill', 'none').style('stroke', '#222').style('shape-rendering', 'crispEdges');\n\n      axisElement.selectAll('line').style('fill', 'none').style('stroke', '#222').style('shape-rendering', 'crispEdges');\n    }).append('svg:text').attr('text-anchor', 'middle').attr('class', 'label').attr('x', 0).attr('y', 0).attr('transform', 'translate(0,-5) rotate(' + config.dimensionTitleRotation + ')').text(dimensionLabels(config)).on('dblclick', flipAxisAndUpdatePCP(config, pc, axis)).on('wheel', rotateLabels(config, pc));\n\n    // Update\n    g_data.attr('opacity', 0);\n    g_data.select('.axis').transition().duration(animationTime).each(function (d) {\n      select(this).call(pc.applyAxisConfig(axis, config.dimensions[d]));\n    });\n    g_data.select('.label').transition().duration(animationTime).text(dimensionLabels(config)).attr('transform', 'translate(0,-5) rotate(' + config.dimensionTitleRotation + ')');\n\n    // Exit\n    g_data.exit().remove();\n\n    var g = pc.svg.selectAll('.dimension');\n    g.transition().duration(animationTime).attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).style('opacity', 1);\n\n    pc.svg.selectAll('.axis').transition().duration(animationTime).each(function (d) {\n      select(this).call(pc.applyAxisConfig(axis, config.dimensions[d]));\n    });\n\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n    return _this$2;\n  };\n};\n\n/** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\nvar getRange = function getRange(config) {\n  var h = config.height - config.margin.top - config.margin.bottom;\n\n  if (config.nullValueSeparator == 'bottom') {\n    return [h + 1 - config.nullValueSeparatorPadding.bottom - config.nullValueSeparatorPadding.top, 1];\n  } else if (config.nullValueSeparator == 'top') {\n    return [h + 1, 1 + config.nullValueSeparatorPadding.bottom + config.nullValueSeparatorPadding.top];\n  }\n  return [h + 1, 1];\n};\n\nvar autoscale = function autoscale(config, pc, xscale, ctx) {\n  return function () {\n    // yscale\n    var defaultScales = {\n      date: function date(k) {\n        var _extent = extent(config.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        });\n        // special case if single value\n        if (_extent[0] === _extent[1]) {\n          return scalePoint().domain(_extent).range(getRange(config));\n        }\n        if (config.flipAxes.includes(k)) {\n          _extent = _extent.map(function (val) {\n            return tempDate.unshift(val);\n          });\n        }\n        return scaleTime().domain(_extent).range(getRange(config));\n      },\n      number: function number(k) {\n        var _extent = extent(config.data, function (d) {\n          return +d[k];\n        });\n        // special case if single value\n        if (_extent[0] === _extent[1]) {\n          return scalePoint().domain(_extent).range(getRange(config));\n        }\n        if (config.flipAxes.includes(k)) {\n          _extent = _extent.map(function (val) {\n            return tempDate.unshift(val);\n          });\n        }\n        return scaleLinear().domain(_extent).range(getRange(config));\n      },\n      string: function string(k) {\n        var counts = {},\n            domain = [];\n        // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n        config.data.map(function (p) {\n          if (p[k] === undefined && config.nullValueSeparator !== 'undefined') {\n            return null; // null values will be drawn beyond the horizontal null value separator!\n          }\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n        if (config.flipAxes.includes(k)) {\n          domain = Object.getOwnPropertyNames(counts).sort();\n        } else {\n          var tempArr = Object.getOwnPropertyNames(counts).sort();\n          for (var i = 0; i < Object.getOwnPropertyNames(counts).length; i++) {\n            domain.push(tempArr.pop());\n          }\n        }\n\n        //need to create an ordinal scale for categorical data\n        var categoricalRange = [];\n        if (domain.length === 1) {\n          //edge case\n          domain = [' ', domain[0], ' '];\n        }\n        var addBy = getRange(config)[0] / (domain.length - 1);\n        for (var j = 0; j < domain.length; j++) {\n          if (categoricalRange.length === 0) {\n            categoricalRange.push(0);\n            continue;\n          }\n          categoricalRange.push(categoricalRange[j - 1] + addBy);\n        }\n        return scaleOrdinal().domain(domain).range(categoricalRange);\n      }\n    };\n    Object.keys(config.dimensions).forEach(function (k) {\n      if (config.dimensions[k].yscale === undefined || config.dimensions[k].yscale === null) {\n        config.dimensions[k].yscale = defaultScales[config.dimensions[k].type](k);\n      }\n    });\n\n    // xscale\n    // add padding for d3 >= v4 default 0.2\n    xscale.range([0, w(config)]).padding(0.2);\n\n    // Retina display, etc.\n    var devicePixelRatio = window.devicePixelRatio || 1;\n\n    // canvas sizes\n    pc.selection.selectAll('canvas').style('margin-top', config.margin.top + 'px').style('margin-left', config.margin.left + 'px').style('width', w(config) + 2 + 'px').style('height', h(config) + 2 + 'px').attr('width', (w(config) + 2) * devicePixelRatio).attr('height', (h(config) + 2) * devicePixelRatio);\n    // default styles, needs to be set when canvas width changes\n    ctx.foreground.strokeStyle = config.color;\n    ctx.foreground.lineWidth = config.lineWidth;\n    ctx.foreground.globalCompositeOperation = config.composite;\n    ctx.foreground.globalAlpha = config.alpha;\n    ctx.foreground.scale(devicePixelRatio, devicePixelRatio);\n    ctx.brushed.strokeStyle = config.brushedColor;\n    ctx.brushed.lineWidth = config.lineWidth;\n    ctx.brushed.globalCompositeOperation = config.composite;\n    ctx.brushed.globalAlpha = config.alpha;\n    ctx.brushed.scale(devicePixelRatio, devicePixelRatio);\n    ctx.highlight.lineWidth = config.highlightedLineWidth;\n    ctx.highlight.scale(devicePixelRatio, devicePixelRatio);\n    ctx.marked.lineWidth = config.markedLineWidth;\n    ctx.marked.shadowColor = config.markedShadowColor;\n    ctx.marked.shadowBlur = config.markedShadowBlur;\n    ctx.marked.scale(devicePixelRatio, devicePixelRatio);\n\n    return this;\n  };\n};\n\nvar brushable = function brushable(config, pc, flags) {\n  return function () {\n    if (!pc.g()) {\n      pc.createAxes();\n    }\n\n    var g = pc.g();\n\n    // Add and store a brush for each axis.\n    g.append('svg:g').attr('class', 'brush').each(function (d) {\n      if (config.dimensions[d] !== undefined) {\n        config.dimensions[d]['brush'] = brushY(select(this)).extent([[-15, 0], [15, config.dimensions[d].yscale.range()[0]]]);\n        select(this).call(config.dimensions[d]['brush'].on('start', function () {\n          if (event.sourceEvent !== null && !event.sourceEvent.ctrlKey) {\n            pc.brushReset();\n          }\n        }).on('brush', function () {\n          if (!event.sourceEvent.ctrlKey) {\n            pc.brush();\n          }\n        }).on('end', function () {\n          // save brush selection is ctrl key is held\n          // store important brush information and\n          // the html element of the selection,\n          // to make a dummy selection element\n          if (event.sourceEvent.ctrlKey) {\n            var html = select(this).select('.selection').nodes()[0].outerHTML;\n            html = html.replace('class=\"selection\"', 'class=\"selection dummy' + ' selection-' + config.brushes.length + '\"');\n            var dat = select(this).nodes()[0].__data__;\n            var brush = {\n              id: config.brushes.length,\n              extent: brushSelection(this),\n              html: html,\n              data: dat\n            };\n            config.brushes.push(brush);\n            select(select(this).nodes()[0].parentNode).select('.axis').nodes()[0].outerHTML += html;\n            pc.brush();\n            config.dimensions[d].brush.move(select(this, null));\n            select(this).select('.selection').attr('style', 'display:none');\n            pc.brushable();\n          } else {\n            pc.brush();\n          }\n        }));\n        select(this).on('dblclick', function () {\n          pc.brushReset(d);\n        });\n      }\n    });\n\n    flags.brushable = true;\n    return this;\n  };\n};\n\nvar commonScale = function commonScale(config, pc) {\n  return function (global, type) {\n    var t = type || 'number';\n    if (typeof global === 'undefined') {\n      global = true;\n    }\n\n    // try to autodetect dimensions and create scales\n    if (!Object.keys(config.dimensions).length) {\n      pc.detectDimensions();\n    }\n    pc.autoscale();\n\n    // scales of the same type\n    var scales = Object.keys(config.dimensions).filter(function (p) {\n      return config.dimensions[p].type == t;\n    });\n\n    if (global) {\n      var _extent = extent(scales.map(function (d) {\n        return config.dimensions[d].yscale.domain();\n      }).reduce(function (cur, acc) {\n        return cur.concat(acc);\n      }));\n\n      scales.forEach(function (d) {\n        config.dimensions[d].yscale.domain(_extent);\n      });\n    } else {\n      scales.forEach(function (d) {\n        config.dimensions[d].yscale.domain(extent(config.data, function (d) {\n          return +d[k];\n        }));\n      });\n    }\n\n    // update centroids\n    if (config.bundleDimension !== null) {\n      pc.bundleDimension(config.bundleDimension);\n    }\n\n    return this;\n  };\n};\n\nvar computeRealCentroids = function computeRealCentroids(config, position) {\n  return function (row) {\n    return Object.keys(config.dimensions).map(function (d) {\n      var x = position(d);\n      var y = config.dimensions[d].yscale(row[d]);\n      return [x, y];\n    });\n  };\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar isValid = function isValid(d) {\n  return d !== null && d !== undefined;\n};\n\nvar applyDimensionDefaults = function applyDimensionDefaults(config, pc) {\n  return function (dims) {\n    var types = pc.detectDimensionTypes(config.data);\n    dims = dims ? dims : Object.keys(types);\n\n    return dims.reduce(function (acc, cur, i) {\n      var k = config.dimensions[cur] ? config.dimensions[cur] : {};\n      acc[cur] = _extends({}, k, {\n        orient: isValid(k.orient) ? k.orient : 'left',\n        ticks: isValid(k.ticks) ? k.ticks : 5,\n        innerTickSize: isValid(k.innerTickSize) ? k.innerTickSize : 6,\n        outerTickSize: isValid(k.outerTickSize) ? k.outerTickSize : 0,\n        tickPadding: isValid(k.tickPadding) ? k.tickPadding : 3,\n        type: isValid(k.type) ? k.type : types[cur],\n        index: isValid(k.index) ? k.index : i\n      });\n\n      return acc;\n    }, {});\n  };\n};\n\n/**\n * Create static SVG axes with dimension names, ticks, and labels.\n *\n * @param config\n * @param pc\n * @param xscale\n * @param flags\n * @param axis\n * @returns {Function}\n */\nvar createAxes = function createAxes(config, pc, xscale, flags, axis) {\n  return function () {\n    if (pc.g() !== undefined) {\n      pc.removeAxes();\n    }\n    // Add a group element for each dimension.\n    pc._g = pc.svg.selectAll('.dimension').data(pc.getOrderedDimensionKeys(), function (d) {\n      return d;\n    }).enter().append('svg:g').attr('class', 'dimension').attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    });\n    // Add an axis and title.\n    pc._g.append('svg:g').attr('class', 'axis').attr('transform', 'translate(0,0)').each(function (d) {\n      var axisElement = select(this).call(pc.applyAxisConfig(axis, config.dimensions[d]));\n\n      axisElement.selectAll('path').style('fill', 'none').style('stroke', '#222').style('shape-rendering', 'crispEdges');\n\n      axisElement.selectAll('line').style('fill', 'none').style('stroke', '#222').style('shape-rendering', 'crispEdges');\n    }).append('svg:text').attr('text-anchor', 'middle').attr('y', 0).attr('transform', 'translate(0,-5) rotate(' + config.dimensionTitleRotation + ')').attr('x', 0).attr('class', 'label').text(dimensionLabels(config)).on('dblclick', flipAxisAndUpdatePCP(config, pc, axis)).on('wheel', rotateLabels(config, pc));\n\n    if (config.nullValueSeparator === 'top') {\n      pc.svg.append('line').attr('x1', 0).attr('y1', 1 + config.nullValueSeparatorPadding.top).attr('x2', w(config)).attr('y2', 1 + config.nullValueSeparatorPadding.top).attr('stroke-width', 1).attr('stroke', '#777').attr('fill', 'none').attr('shape-rendering', 'crispEdges');\n    } else if (config.nullValueSeparator === 'bottom') {\n      pc.svg.append('line').attr('x1', 0).attr('y1', h(config) + 1 - config.nullValueSeparatorPadding.bottom).attr('x2', w(config)).attr('y2', h(config) + 1 - config.nullValueSeparatorPadding.bottom).attr('stroke-width', 1).attr('stroke', '#777').attr('fill', 'none').attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n};\n\nvar _this$3 = undefined;\n\n//draw dots with radius r on the axis line where data intersects\nvar axisDots = function axisDots(config, pc, position) {\n  return function (_r) {\n    var r = _r || 0.1;\n    var ctx = pc.ctx.dots;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = min([1 / Math.pow(config.data.length, 1 / 2), 1]);\n    config.data.forEach(function (d) {\n      entries(config.dimensions).forEach(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), config.dimensions[p.key].yscale(d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n    return _this$3;\n  };\n};\n\nvar applyAxisConfig = function applyAxisConfig(axis, dimension) {\n  var axisCfg = void 0;\n\n  switch (dimension.orient) {\n    case 'left':\n      axisCfg = axisLeft(dimension.yscale);\n      break;\n    case 'right':\n      axisCfg = axisRight(dimension.yscale);\n      break;\n    case 'top':\n      axisCfg = axisTop(dimension.yscale);\n      break;\n    case 'bottom':\n      axisCfg = axisBottom(dimension.yscale);\n      break;\n    default:\n      axisCfg = axisLeft(dimension.yscale);\n      break;\n  }\n\n  axisCfg.ticks(dimension.ticks).tickValues(dimension.tickValues).tickSizeInner(dimension.innerTickSize).tickSizeOuter(dimension.outerTickSize).tickPadding(dimension.tickPadding).tickFormat(dimension.tickFormat);\n\n  return axisCfg;\n};\n\n// Jason Davies, http://bl.ocks.org/1341281\nvar reorderable = function reorderable(config, pc, xscale, position, dragging, flags) {\n  return function () {\n    if (pc.g() === undefined) pc.createAxes();\n    var g = pc.g();\n\n    g.style('cursor', 'move').call(drag().on('start', function (d) {\n      dragging[d] = this.__origin__ = xscale(d);\n    }).on('drag', function (d) {\n      dragging[d] = Math.min(w(config), Math.max(0, this.__origin__ += event.dx));\n      pc.sortDimensions();\n      xscale.domain(pc.getOrderedDimensionKeys());\n      pc.render();\n      g.attr('transform', function (d) {\n        return 'translate(' + position(d) + ')';\n      });\n    }).on('end', function (d) {\n      delete this.__origin__;\n      delete dragging[d];\n      select(this).transition().attr('transform', 'translate(' + xscale(d) + ')');\n      pc.render();\n      pc.renderMarked();\n    }));\n    flags.reorderable = true;\n    return this;\n  };\n};\n\n// rescale for height, width and margins\n// TODO currently assumes chart is brushable, and destroys old brushes\nvar resize = function resize(config, pc, flags, events) {\n  return function () {\n    // selection size\n    pc.selection.select('svg').attr('width', config.width).attr('height', config.height);\n    pc.svg.attr('transform', 'translate(' + config.margin.left + ',' + config.margin.top + ')');\n\n    // FIXME: the current brush state should pass through\n    if (flags.brushable) pc.brushReset();\n\n    // scales\n    pc.autoscale();\n\n    // axes, destroys old brushes.\n    if (pc.g()) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    events.call('resize', this, {\n      width: config.width,\n      height: config.height,\n      margin: config.margin\n    });\n\n    return this;\n  };\n};\n\n// Reorder dimensions, such that the highest value (visually) is on the left and\n// the lowest on the right. Visual values are determined by the data values in\n// the given row.\nvar reorder = function reorder(config, pc, xscale) {\n  return function (rowdata) {\n    var firstDim = pc.getOrderedDimensionKeys()[0];\n\n    pc.sortDimensionsByRowData(rowdata);\n    // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n    var reordered = firstDim !== pc.getOrderedDimensionKeys()[0];\n\n    if (reordered) {\n      xscale.domain(pc.getOrderedDimensionKeys());\n      var highlighted = config.highlighted.slice(0);\n      pc.unhighlight();\n\n      var marked = config.marked.slice(0);\n      pc.unmark();\n\n      var g = pc.g();\n      g.transition().duration(1500).attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render();\n\n      // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n      if (marked.length !== 0) {\n        pc.mark(marked);\n      }\n    }\n  };\n};\n\nvar sortDimensions = function sortDimensions(config, position) {\n  return function () {\n    var copy = Object.assign({}, config.dimensions);\n    var positionSortedKeys = Object.keys(config.dimensions).sort(function (a, b) {\n      return position(a) - position(b) === 0 ? 1 : position(a) - position(b);\n    });\n    config.dimensions = {};\n    positionSortedKeys.forEach(function (p, i) {\n      config.dimensions[p] = copy[p];\n      config.dimensions[p].index = i;\n    });\n  };\n};\n\nvar sortDimensionsByRowData = function sortDimensionsByRowData(config) {\n  return function (rowdata) {\n    var copy = Object.assign({}, config.dimensions);\n    var positionSortedKeys = Object.keys(config.dimensions).sort(function (a, b) {\n      var pixelDifference = config.dimensions[a].yscale(rowdata[a]) - config.dimensions[b].yscale(rowdata[b]);\n\n      // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n      return pixelDifference === 0 ? a.localeCompare(b) : pixelDifference;\n    });\n    config.dimensions = {};\n    positionSortedKeys.forEach(function (p, i) {\n      config.dimensions[p] = copy[p];\n      config.dimensions[p].index = i;\n    });\n  };\n};\n\nvar isBrushed = function isBrushed(config, brushGroup) {\n  if (config.brushed && config.brushed.length !== config.data.length) return true;\n\n  var object = brushGroup.currentMode().brushState();\n\n  for (var key in object) {\n    if (object.hasOwnProperty(key)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvar clear = function clear(config, pc, ctx, brushGroup) {\n  return function (layer) {\n    ctx[layer].clearRect(0, 0, w(config) + 2, h(config) + 2);\n\n    // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n    if (layer === 'brushed' && isBrushed(config, brushGroup)) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - config.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w(config) + 2, h(config) + 2);\n      ctx.brushed.globalAlpha = config.alpha;\n    }\n    return this;\n  };\n};\n\nvar PRECISION = 1e-6;\n\nvar Matrix = function () {\n    function Matrix(elements) {\n        classCallCheck(this, Matrix);\n\n        this.setElements(elements);\n    }\n\n    createClass(Matrix, [{\n        key: \"e\",\n        value: function e(i, j) {\n            if (i < 1 || i > this.elements.length || j < 1 || j > this.elements[0].length) {\n                return null;\n            }\n            return this.elements[i - 1][j - 1];\n        }\n    }, {\n        key: \"row\",\n        value: function row(i) {\n            if (i > this.elements.length) {\n                return null;\n            }\n            return new Vector(this.elements[i - 1]);\n        }\n    }, {\n        key: \"col\",\n        value: function col(j) {\n            if (this.elements.length === 0) {\n                return null;\n            }\n            if (j > this.elements[0].length) {\n                return null;\n            }\n            var col = [],\n                n = this.elements.length;\n            for (var i = 0; i < n; i++) {\n                col.push(this.elements[i][j - 1]);\n            }\n            return new Vector(col);\n        }\n    }, {\n        key: \"dimensions\",\n        value: function dimensions() {\n            var cols = this.elements.length === 0 ? 0 : this.elements[0].length;\n            return { rows: this.elements.length, cols: cols };\n        }\n    }, {\n        key: \"rows\",\n        value: function rows() {\n            return this.elements.length;\n        }\n    }, {\n        key: \"cols\",\n        value: function cols() {\n            if (this.elements.length === 0) {\n                return 0;\n            }\n            return this.elements[0].length;\n        }\n    }, {\n        key: \"eql\",\n        value: function eql(matrix) {\n            var M = matrix.elements || matrix;\n            if (!M[0] || typeof M[0][0] === 'undefined') {\n                M = new Matrix(M).elements;\n            }\n            if (this.elements.length === 0 || M.length === 0) {\n                return this.elements.length === M.length;\n            }\n            if (this.elements.length !== M.length) {\n                return false;\n            }\n            if (this.elements[0].length !== M[0].length) {\n                return false;\n            }\n            var i = this.elements.length,\n                nj = this.elements[0].length,\n                j;\n            while (i--) {\n                j = nj;\n                while (j--) {\n                    if (Math.abs(this.elements[i][j] - M[i][j]) > PRECISION) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    }, {\n        key: \"dup\",\n        value: function dup() {\n            return new Matrix(this.elements);\n        }\n    }, {\n        key: \"map\",\n        value: function map(fn, context) {\n            if (this.elements.length === 0) {\n                return new Matrix([]);\n            }\n            var els = [],\n                i = this.elements.length,\n                nj = this.elements[0].length,\n                j;\n            while (i--) {\n                j = nj;\n                els[i] = [];\n                while (j--) {\n                    els[i][j] = fn.call(context, this.elements[i][j], i + 1, j + 1);\n                }\n            }\n            return new Matrix(els);\n        }\n    }, {\n        key: \"isSameSizeAs\",\n        value: function isSameSizeAs(matrix) {\n            var M = matrix.elements || matrix;\n            if (typeof M[0][0] === 'undefined') {\n                M = new Matrix(M).elements;\n            }\n            if (this.elements.length === 0) {\n                return M.length === 0;\n            }\n            return this.elements.length === M.length && this.elements[0].length === M[0].length;\n        }\n    }, {\n        key: \"add\",\n        value: function add(matrix) {\n            if (this.elements.length === 0) {\n                return this.map(function (x) {\n                    return x;\n                });\n            }\n            var M = matrix.elements || matrix;\n            if (typeof M[0][0] === 'undefined') {\n                M = new Matrix(M).elements;\n            }\n            if (!this.isSameSizeAs(M)) {\n                return null;\n            }\n            return this.map(function (x, i, j) {\n                return x + M[i - 1][j - 1];\n            });\n        }\n    }, {\n        key: \"subtract\",\n        value: function subtract(matrix) {\n            if (this.elements.length === 0) {\n                return this.map(function (x) {\n                    return x;\n                });\n            }\n            var M = matrix.elements || matrix;\n            if (typeof M[0][0] === 'undefined') {\n                M = new Matrix(M).elements;\n            }\n            if (!this.isSameSizeAs(M)) {\n                return null;\n            }\n            return this.map(function (x, i, j) {\n                return x - M[i - 1][j - 1];\n            });\n        }\n    }, {\n        key: \"canMultiplyFromLeft\",\n        value: function canMultiplyFromLeft(matrix) {\n            if (this.elements.length === 0) {\n                return false;\n            }\n            var M = matrix.elements || matrix;\n            if (typeof M[0][0] === 'undefined') {\n                M = new Matrix(M).elements;\n            }\n            // this.columns should equal matrix.rows\n            return this.elements[0].length === M.length;\n        }\n    }, {\n        key: \"multiply\",\n        value: function multiply(matrix) {\n            if (this.elements.length === 0) {\n                return null;\n            }\n            if (!matrix.elements) {\n                return this.map(function (x) {\n                    return x * matrix;\n                });\n            }\n            var returnVector = matrix.modulus ? true : false;\n            var M = matrix.elements || matrix;\n            if (typeof M[0][0] === 'undefined') {\n                M = new Matrix(M).elements;\n            }\n            if (!this.canMultiplyFromLeft(M)) {\n                return null;\n            }\n            var i = this.elements.length,\n                nj = M[0].length,\n                j;\n            var cols = this.elements[0].length,\n                c,\n                elements = [],\n                sum;\n            while (i--) {\n                j = nj;\n                elements[i] = [];\n                while (j--) {\n                    c = cols;\n                    sum = 0;\n                    while (c--) {\n                        sum += this.elements[i][c] * M[c][j];\n                    }\n                    elements[i][j] = sum;\n                }\n            }\n            var M = new Matrix(elements);\n            return returnVector ? M.col(1) : M;\n        }\n    }, {\n        key: \"minor\",\n        value: function minor(a, b, c, d) {\n            if (this.elements.length === 0) {\n                return null;\n            }\n            var elements = [],\n                ni = c,\n                i,\n                nj,\n                j;\n            var rows = this.elements.length,\n                cols = this.elements[0].length;\n            while (ni--) {\n                i = c - ni - 1;\n                elements[i] = [];\n                nj = d;\n                while (nj--) {\n                    j = d - nj - 1;\n                    elements[i][j] = this.elements[(a + i - 1) % rows][(b + j - 1) % cols];\n                }\n            }\n            return new Matrix(elements);\n        }\n    }, {\n        key: \"transpose\",\n        value: function transpose() {\n            if (this.elements.length === 0) {\n                return new Matrix([]);\n            }\n            var rows = this.elements.length,\n                i,\n                cols = this.elements[0].length,\n                j;\n            var elements = [],\n                i = cols;\n            while (i--) {\n                j = rows;\n                elements[i] = [];\n                while (j--) {\n                    elements[i][j] = this.elements[j][i];\n                }\n            }\n            return new Matrix(elements);\n        }\n    }, {\n        key: \"isSquare\",\n        value: function isSquare() {\n            var cols = this.elements.length === 0 ? 0 : this.elements[0].length;\n            return this.elements.length === cols;\n        }\n    }, {\n        key: \"max\",\n        value: function max() {\n            if (this.elements.length === 0) {\n                return null;\n            }\n            var m = 0,\n                i = this.elements.length,\n                nj = this.elements[0].length,\n                j;\n            while (i--) {\n                j = nj;\n                while (j--) {\n                    if (Math.abs(this.elements[i][j]) > Math.abs(m)) {\n                        m = this.elements[i][j];\n                    }\n                }\n            }\n            return m;\n        }\n    }, {\n        key: \"indexOf\",\n        value: function indexOf(x) {\n            if (this.elements.length === 0) {\n                return null;\n            }\n            var ni = this.elements.length,\n                i,\n                nj = this.elements[0].length,\n                j;\n            for (i = 0; i < ni; i++) {\n                for (j = 0; j < nj; j++) {\n                    if (this.elements[i][j] === x) {\n                        return {\n                            i: i + 1,\n                            j: j + 1\n                        };\n                    }\n                }\n            }\n            return null;\n        }\n    }, {\n        key: \"diagonal\",\n        value: function diagonal() {\n            if (!this.isSquare) {\n                return null;\n            }\n            var els = [],\n                n = this.elements.length;\n            for (var i = 0; i < n; i++) {\n                els.push(this.elements[i][i]);\n            }\n            return new Vector(els);\n        }\n    }, {\n        key: \"toRightTriangular\",\n        value: function toRightTriangular() {\n            if (this.elements.length === 0) {\n                return new Matrix([]);\n            }\n            var M = this.dup(),\n                els;\n            var n = this.elements.length,\n                i,\n                j,\n                np = this.elements[0].length,\n                p;\n            for (i = 0; i < n; i++) {\n                if (M.elements[i][i] === 0) {\n                    for (j = i + 1; j < n; j++) {\n                        if (M.elements[j][i] !== 0) {\n                            els = [];\n                            for (p = 0; p < np; p++) {\n                                els.push(M.elements[i][p] + M.elements[j][p]);\n                            }\n                            M.elements[i] = els;\n                            break;\n                        }\n                    }\n                }\n                if (M.elements[i][i] !== 0) {\n                    for (j = i + 1; j < n; j++) {\n                        var multiplier = M.elements[j][i] / M.elements[i][i];\n                        els = [];\n                        for (p = 0; p < np; p++) {\n                            // Elements with column numbers up to an including the number of the\n                            // row that we're subtracting can safely be set straight to zero,\n                            // since that's the point of this routine and it avoids having to\n                            // loop over and correct rounding errors later\n                            els.push(p <= i ? 0 : M.elements[j][p] - M.elements[i][p] * multiplier);\n                        }\n                        M.elements[j] = els;\n                    }\n                }\n            }\n            return M;\n        }\n    }, {\n        key: \"determinant\",\n        value: function determinant() {\n            if (this.elements.length === 0) {\n                return 1;\n            }\n            if (!this.isSquare()) {\n                return null;\n            }\n            var M = this.toRightTriangular();\n            var det = M.elements[0][0],\n                n = M.elements.length;\n            for (var i = 1; i < n; i++) {\n                det = det * M.elements[i][i];\n            }\n            return det;\n        }\n    }, {\n        key: \"isSingular\",\n        value: function isSingular() {\n            return this.isSquare() && this.determinant() === 0;\n        }\n    }, {\n        key: \"trace\",\n        value: function trace() {\n            if (this.elements.length === 0) {\n                return 0;\n            }\n            if (!this.isSquare()) {\n                return null;\n            }\n            var tr = this.elements[0][0],\n                n = this.elements.length;\n            for (var i = 1; i < n; i++) {\n                tr += this.elements[i][i];\n            }\n            return tr;\n        }\n    }, {\n        key: \"rank\",\n        value: function rank() {\n            if (this.elements.length === 0) {\n                return 0;\n            }\n            var M = this.toRightTriangular(),\n                rank = 0;\n            var i = this.elements.length,\n                nj = this.elements[0].length,\n                j;\n            while (i--) {\n                j = nj;\n                while (j--) {\n                    if (Math.abs(M.elements[i][j]) > PRECISION) {\n                        rank++;\n                        break;\n                    }\n                }\n            }\n            return rank;\n        }\n    }, {\n        key: \"augment\",\n        value: function augment(matrix) {\n            if (this.elements.length === 0) {\n                return this.dup();\n            }\n            var M = matrix.elements || matrix;\n            if (typeof M[0][0] === 'undefined') {\n                M = new Matrix(M).elements;\n            }\n            var T = this.dup(),\n                cols = T.elements[0].length;\n            var i = T.elements.length,\n                nj = M[0].length,\n                j;\n            if (i !== M.length) {\n                return null;\n            }\n            while (i--) {\n                j = nj;\n                while (j--) {\n                    T.elements[i][cols + j] = M[i][j];\n                }\n            }\n            return T;\n        }\n    }, {\n        key: \"inverse\",\n        value: function inverse() {\n            if (this.elements.length === 0) {\n                return null;\n            }\n            if (!this.isSquare() || this.isSingular()) {\n                return null;\n            }\n            var n = this.elements.length,\n                i = n,\n                j;\n            var M = this.augment(Matrix.I(n)).toRightTriangular();\n            var np = M.elements[0].length,\n                p,\n                els,\n                divisor;\n            var inverse_elements = [],\n                new_element;\n            // Matrix is non-singular so there will be no zeros on the\n            // diagonal. Cycle through rows from last to first.\n            while (i--) {\n                // First, normalise diagonal elements to 1\n                els = [];\n                inverse_elements[i] = [];\n                divisor = M.elements[i][i];\n                for (p = 0; p < np; p++) {\n                    new_element = M.elements[i][p] / divisor;\n                    els.push(new_element);\n                    // Shuffle off the current row of the right hand side into the results\n                    // array as it will not be modified by later runs through this loop\n                    if (p >= n) {\n                        inverse_elements[i].push(new_element);\n                    }\n                }\n                M.elements[i] = els;\n                // Then, subtract this row from those above it to give the identity matrix\n                // on the left hand side\n                j = i;\n                while (j--) {\n                    els = [];\n                    for (p = 0; p < np; p++) {\n                        els.push(M.elements[j][p] - M.elements[i][p] * M.elements[j][i]);\n                    }\n                    M.elements[j] = els;\n                }\n            }\n            return new Matrix(inverse_elements);\n        }\n    }, {\n        key: \"round\",\n        value: function round() {\n            return this.map(function (x) {\n                return Math.round(x);\n            });\n        }\n    }, {\n        key: \"snapTo\",\n        value: function snapTo(x) {\n            return this.map(function (p) {\n                return Math.abs(p - x) <= PRECISION ? x : p;\n            });\n        }\n    }, {\n        key: \"inspect\",\n        value: function inspect() {\n            var matrix_rows = [];\n            var n = this.elements.length;\n            if (n === 0) return '[]';\n            for (var i = 0; i < n; i++) {\n                matrix_rows.push(new Vector(this.elements[i]).inspect());\n            }\n            return matrix_rows.join('\\n');\n        }\n    }, {\n        key: \"setElements\",\n        value: function setElements(els) {\n            var i,\n                j,\n                elements = els.elements || els;\n            if (elements[0] && typeof elements[0][0] !== 'undefined') {\n                i = elements.length;\n                this.elements = [];\n                while (i--) {\n                    j = elements[i].length;\n                    this.elements[i] = [];\n                    while (j--) {\n                        this.elements[i][j] = elements[i][j];\n                    }\n                }\n                return this;\n            }\n            var n = elements.length;\n            this.elements = [];\n            for (i = 0; i < n; i++) {\n                this.elements.push([elements[i]]);\n            }\n            return this;\n        }\n\n        //From glUtils.js\n\n    }, {\n        key: \"flatten\",\n        value: function flatten() {\n            var result = [];\n            if (this.elements.length == 0) {\n                return [];\n            }\n\n            for (var j = 0; j < this.elements[0].length; j++) {\n                for (var i = 0; i < this.elements.length; i++) {\n                    result.push(this.elements[i][j]);\n                }\n            }\n            return result;\n        }\n\n        //From glUtils.js\n\n    }, {\n        key: \"ensure4x4\",\n        value: function ensure4x4() {\n            if (this.elements.length == 4 && this.elements[0].length == 4) {\n                return this;\n            }\n\n            if (this.elements.length > 4 || this.elements[0].length > 4) {\n                return null;\n            }\n\n            for (var i = 0; i < this.elements.length; i++) {\n                for (var j = this.elements[i].length; j < 4; j++) {\n                    if (i == j) {\n                        this.elements[i].push(1);\n                    } else {\n                        this.elements[i].push(0);\n                    }\n                }\n            }\n\n            for (var i = this.elements.length; i < 4; i++) {\n                if (i == 0) {\n                    this.elements.push([1, 0, 0, 0]);\n                } else if (i == 1) {\n                    this.elements.push([0, 1, 0, 0]);\n                } else if (i == 2) {\n                    this.elements.push([0, 0, 1, 0]);\n                } else if (i == 3) {\n                    this.elements.push([0, 0, 0, 1]);\n                }\n            }\n\n            return this;\n        }\n\n        //From glUtils.js\n\n    }, {\n        key: \"make3x3\",\n        value: function make3x3() {\n            if (this.elements.length != 4 || this.elements[0].length != 4) {\n                return null;\n            }\n\n            return new Matrix([[this.elements[0][0], this.elements[0][1], this.elements[0][2]], [this.elements[1][0], this.elements[1][1], this.elements[1][2]], [this.elements[2][0], this.elements[2][1], this.elements[2][2]]]);\n        }\n    }]);\n    return Matrix;\n}();\n\nMatrix.I = function (n) {\n    var els = [],\n        i = n,\n        j;\n    while (i--) {\n        j = n;\n        els[i] = [];\n        while (j--) {\n            els[i][j] = i === j ? 1 : 0;\n        }\n    }\n    return new Matrix(els);\n};\n\nMatrix.Diagonal = function (elements) {\n    var i = elements.length;\n    var M = Matrix.I(i);\n    while (i--) {\n        M.elements[i][i] = elements[i];\n    }\n    return M;\n};\n\nMatrix.Rotation = function (theta, a) {\n    if (!a) {\n        return new Matrix([[Math.cos(theta), -Math.sin(theta)], [Math.sin(theta), Math.cos(theta)]]);\n    }\n    var axis = a.dup();\n    if (axis.elements.length !== 3) {\n        return null;\n    }\n    var mod = axis.modulus();\n    var x = axis.elements[0] / mod,\n        y = axis.elements[1] / mod,\n        z = axis.elements[2] / mod;\n    var s = Math.sin(theta),\n        c = Math.cos(theta),\n        t = 1 - c;\n    // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp\n    // That proof rotates the co-ordinate system so theta becomes -theta and sin\n    // becomes -sin here.\n    return new Matrix([[t * x * x + c, t * x * y - s * z, t * x * z + s * y], [t * x * y + s * z, t * y * y + c, t * y * z - s * x], [t * x * z - s * y, t * y * z + s * x, t * z * z + c]]);\n};\n\nMatrix.RotationX = function (t) {\n    var c = Math.cos(t),\n        s = Math.sin(t);\n    return new Matrix([[1, 0, 0], [0, c, -s], [0, s, c]]);\n};\nMatrix.RotationY = function (t) {\n    var c = Math.cos(t),\n        s = Math.sin(t);\n    return new Matrix([[c, 0, s], [0, 1, 0], [-s, 0, c]]);\n};\nMatrix.RotationZ = function (t) {\n    var c = Math.cos(t),\n        s = Math.sin(t);\n    return new Matrix([[c, -s, 0], [s, c, 0], [0, 0, 1]]);\n};\n\nMatrix.Random = function (n, m) {\n    return Matrix.Zero(n, m).map(function () {\n        return Math.random();\n    });\n};\n\n//From glUtils.js\nMatrix.Translation = function (v) {\n    if (v.elements.length == 2) {\n        var r = Matrix.I(3);\n        r.elements[2][0] = v.elements[0];\n        r.elements[2][1] = v.elements[1];\n        return r;\n    }\n\n    if (v.elements.length == 3) {\n        var r = Matrix.I(4);\n        r.elements[0][3] = v.elements[0];\n        r.elements[1][3] = v.elements[1];\n        r.elements[2][3] = v.elements[2];\n        return r;\n    }\n\n    throw \"Invalid length for Translation\";\n};\n\nMatrix.Zero = function (n, m) {\n    var els = [],\n        i = n,\n        j;\n    while (i--) {\n        j = m;\n        els[i] = [];\n        while (j--) {\n            els[i][j] = 0;\n        }\n    }\n    return new Matrix(els);\n};\n\nMatrix.prototype.toUpperTriangular = Matrix.prototype.toRightTriangular;\nMatrix.prototype.det = Matrix.prototype.determinant;\nMatrix.prototype.tr = Matrix.prototype.trace;\nMatrix.prototype.rk = Matrix.prototype.rank;\nMatrix.prototype.inv = Matrix.prototype.inverse;\nMatrix.prototype.x = Matrix.prototype.multiply;\n\nvar Vector = function () {\n    function Vector(elements) {\n        classCallCheck(this, Vector);\n\n        this.setElements(elements);\n    }\n\n    createClass(Vector, [{\n        key: \"e\",\n        value: function e(i) {\n            return i < 1 || i > this.elements.length ? null : this.elements[i - 1];\n        }\n    }, {\n        key: \"dimensions\",\n        value: function dimensions() {\n            return this.elements.length;\n        }\n    }, {\n        key: \"modulus\",\n        value: function modulus() {\n            return Math.sqrt(this.dot(this));\n        }\n    }, {\n        key: \"eql\",\n        value: function eql(vector) {\n            var n = this.elements.length;\n            var V = vector.elements || vector;\n            if (n !== V.length) {\n                return false;\n            }\n            while (n--) {\n                if (Math.abs(this.elements[n] - V[n]) > PRECISION) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }, {\n        key: \"dup\",\n        value: function dup() {\n            return new Vector(this.elements);\n        }\n    }, {\n        key: \"map\",\n        value: function map(fn, context) {\n            var elements = [];\n            this.each(function (x, i) {\n                elements.push(fn.call(context, x, i));\n            });\n            return new Vector(elements);\n        }\n    }, {\n        key: \"forEach\",\n        value: function forEach(fn, context) {\n            var n = this.elements.length;\n            for (var i = 0; i < n; i++) {\n                fn.call(context, this.elements[i], i + 1);\n            }\n        }\n    }, {\n        key: \"toUnitVector\",\n        value: function toUnitVector() {\n            var r = this.modulus();\n            if (r === 0) {\n                return this.dup();\n            }\n            return this.map(function (x) {\n                return x / r;\n            });\n        }\n    }, {\n        key: \"angleFrom\",\n        value: function angleFrom(vector) {\n            var V = vector.elements || vector;\n            var n = this.elements.length;\n            if (n !== V.length) {\n                return null;\n            }\n            var dot = 0,\n                mod1 = 0,\n                mod2 = 0;\n            // Work things out in parallel to save time\n            this.each(function (x, i) {\n                dot += x * V[i - 1];\n                mod1 += x * x;\n                mod2 += V[i - 1] * V[i - 1];\n            });\n            mod1 = Math.sqrt(mod1);mod2 = Math.sqrt(mod2);\n            if (mod1 * mod2 === 0) {\n                return null;\n            }\n            var theta = dot / (mod1 * mod2);\n            if (theta < -1) {\n                theta = -1;\n            }\n            if (theta > 1) {\n                theta = 1;\n            }\n            return Math.acos(theta);\n        }\n    }, {\n        key: \"isParallelTo\",\n        value: function isParallelTo(vector) {\n            var angle = this.angleFrom(vector);\n            return angle === null ? null : angle <= PRECISION;\n        }\n    }, {\n        key: \"isAntiparallelTo\",\n        value: function isAntiparallelTo(vector) {\n            var angle = this.angleFrom(vector);\n            return angle === null ? null : Math.abs(angle - Math.PI) <= PRECISION;\n        }\n    }, {\n        key: \"isPerpendicularTo\",\n        value: function isPerpendicularTo(vector) {\n            var dot = this.dot(vector);\n            return dot === null ? null : Math.abs(dot) <= PRECISION;\n        }\n    }, {\n        key: \"add\",\n        value: function add(vector) {\n            var V = vector.elements || vector;\n            if (this.elements.length !== V.length) {\n                return null;\n            }\n            return this.map(function (x, i) {\n                return x + V[i - 1];\n            });\n        }\n    }, {\n        key: \"subtract\",\n        value: function subtract(vector) {\n            var V = vector.elements || vector;\n            if (this.elements.length !== V.length) {\n                return null;\n            }\n            return this.map(function (x, i) {\n                return x - V[i - 1];\n            });\n        }\n    }, {\n        key: \"multiply\",\n        value: function multiply(k) {\n            return this.map(function (x) {\n                return x * k;\n            });\n        }\n    }, {\n        key: \"dot\",\n        value: function dot(vector) {\n            var V = vector.elements || vector;\n            var product = 0,\n                n = this.elements.length;\n            if (n !== V.length) {\n                return null;\n            }\n            while (n--) {\n                product += this.elements[n] * V[n];\n            }\n            return product;\n        }\n    }, {\n        key: \"cross\",\n        value: function cross(vector) {\n            var B = vector.elements || vector;\n            if (this.elements.length !== 3 || B.length !== 3) {\n                return null;\n            }\n            var A = this.elements;\n            return new Vector([A[1] * B[2] - A[2] * B[1], A[2] * B[0] - A[0] * B[2], A[0] * B[1] - A[1] * B[0]]);\n        }\n    }, {\n        key: \"max\",\n        value: function max() {\n            var m = 0,\n                i = this.elements.length;\n            while (i--) {\n                if (Math.abs(this.elements[i]) > Math.abs(m)) {\n                    m = this.elements[i];\n                }\n            }\n            return m;\n        }\n    }, {\n        key: \"indexOf\",\n        value: function indexOf(x) {\n            var index = null,\n                n = this.elements.length;\n            for (var i = 0; i < n; i++) {\n                if (index === null && this.elements[i] === x) {\n                    index = i + 1;\n                }\n            }\n            return index;\n        }\n    }, {\n        key: \"toDiagonalMatrix\",\n        value: function toDiagonalMatrix() {\n            return Matrix.Diagonal(this.elements);\n        }\n    }, {\n        key: \"round\",\n        value: function round() {\n            return this.map(function (x) {\n                return Math.round(x);\n            });\n        }\n    }, {\n        key: \"snapTo\",\n        value: function snapTo(x) {\n            return this.map(function (y) {\n                return Math.abs(y - x) <= PRECISION ? x : y;\n            });\n        }\n    }, {\n        key: \"distanceFrom\",\n        value: function distanceFrom(obj) {\n            if (obj.anchor || obj.start && obj.end) {\n                return obj.distanceFrom(this);\n            }\n            var V = obj.elements || obj;\n            if (V.length !== this.elements.length) {\n                return null;\n            }\n            var sum = 0,\n                part;\n            this.each(function (x, i) {\n                part = x - V[i - 1];\n                sum += part * part;\n            });\n            return Math.sqrt(sum);\n        }\n    }, {\n        key: \"liesOn\",\n        value: function liesOn(line) {\n            return line.contains(this);\n        }\n    }, {\n        key: \"liesIn\",\n        value: function liesIn(plane) {\n            return plane.contains(this);\n        }\n    }, {\n        key: \"rotate\",\n        value: function rotate(t, obj) {\n            var V,\n                R = null,\n                x,\n                y,\n                z;\n            if (t.determinant) {\n                R = t.elements;\n            }\n            switch (this.elements.length) {\n                case 2:\n                    {\n                        V = obj.elements || obj;\n                        if (V.length !== 2) {\n                            return null;\n                        }\n                        if (!R) {\n                            R = Matrix.Rotation(t).elements;\n                        }\n                        x = this.elements[0] - V[0];\n                        y = this.elements[1] - V[1];\n                        return new Vector([V[0] + R[0][0] * x + R[0][1] * y, V[1] + R[1][0] * x + R[1][1] * y]);\n                        break;\n                    }\n                case 3:\n                    {\n                        if (!obj.direction) {\n                            return null;\n                        }\n                        var C = obj.pointClosestTo(this).elements;\n                        if (!R) {\n                            R = Matrix.Rotation(t, obj.direction).elements;\n                        }\n                        x = this.elements[0] - C[0];\n                        y = this.elements[1] - C[1];\n                        z = this.elements[2] - C[2];\n                        return new Vector([C[0] + R[0][0] * x + R[0][1] * y + R[0][2] * z, C[1] + R[1][0] * x + R[1][1] * y + R[1][2] * z, C[2] + R[2][0] * x + R[2][1] * y + R[2][2] * z]);\n                        break;\n                    }\n                default:\n                    {\n                        return null;\n                    }\n            }\n        }\n    }, {\n        key: \"reflectionIn\",\n        value: function reflectionIn(obj) {\n            if (obj.anchor) {\n                // obj is a plane or line\n                var P = this.elements.slice();\n                var C = obj.pointClosestTo(P).elements;\n                return new Vector([C[0] + (C[0] - P[0]), C[1] + (C[1] - P[1]), C[2] + (C[2] - (P[2] || 0))]);\n            } else {\n                // obj is a point\n                var Q = obj.elements || obj;\n                if (this.elements.length !== Q.length) {\n                    return null;\n                }\n                return this.map(function (x, i) {\n                    return Q[i - 1] + (Q[i - 1] - x);\n                });\n            }\n        }\n    }, {\n        key: \"to3D\",\n        value: function to3D() {\n            var V = this.dup();\n            switch (V.elements.length) {\n                case 3:\n                    {\n                        break;\n                    }\n                case 2:\n                    {\n                        V.elements.push(0);\n                        break;\n                    }\n                default:\n                    {\n                        return null;\n                    }\n            }\n            return V;\n        }\n    }, {\n        key: \"inspect\",\n        value: function inspect() {\n            return '[' + this.elements.join(', ') + ']';\n        }\n    }, {\n        key: \"setElements\",\n        value: function setElements(els) {\n            this.elements = (els.elements || els).slice();\n            return this;\n        }\n\n        //From glUtils.js\n\n    }, {\n        key: \"flatten\",\n        value: function flatten() {\n            return this.elements;\n        }\n    }]);\n    return Vector;\n}();\n\nVector.Random = function (n) {\n    var elements = [];\n    while (n--) {\n        elements.push(Math.random());\n    }\n    return new Vector(elements);\n};\n\nVector.Zero = function (n) {\n    var elements = [];\n    while (n--) {\n        elements.push(0);\n    }\n    return new Vector(elements);\n};\n\nVector.prototype.x = Vector.prototype.multiply;\nVector.prototype.each = Vector.prototype.forEach;\n\nVector.i = new Vector([1, 0, 0]);\nVector.j = new Vector([0, 1, 0]);\nVector.k = new Vector([0, 0, 1]);\n\nvar computeCentroids = function computeCentroids(config, position, row) {\n  var centroids = [];\n\n  var p = Object.keys(config.dimensions);\n  var cols = p.length;\n  var a = 0.5; // center between axes\n  for (var i = 0; i < cols; ++i) {\n    // centroids on 'real' axes\n    var x = position(p[i]);\n    var y = config.dimensions[p[i]].yscale(row[p[i]]);\n    centroids.push(new Vector([x, y]));\n\n    // centroids on 'virtual' axes\n    if (i < cols - 1) {\n      var cx = x + a * (position(p[i + 1]) - x);\n      var cy = y + a * (config.dimensions[p[i + 1]].yscale(row[p[i + 1]]) - y);\n      if (config.bundleDimension !== null) {\n        var leftCentroid = config.clusterCentroids.get(config.dimensions[config.bundleDimension].yscale(row[config.bundleDimension])).get(p[i]);\n        var rightCentroid = config.clusterCentroids.get(config.dimensions[config.bundleDimension].yscale(row[config.bundleDimension])).get(p[i + 1]);\n        var centroid = 0.5 * (leftCentroid + rightCentroid);\n        cy = centroid + (1 - config.bundlingStrength) * (cy - centroid);\n      }\n      centroids.push(new Vector([cx, cy]));\n    }\n  }\n\n  return centroids;\n};\n\nvar computeControlPoints = function computeControlPoints(smoothness, centroids) {\n  var cols = centroids.length;\n  var a = smoothness;\n  var cps = [];\n\n  cps.push(centroids[0]);\n  cps.push(new Vector([centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)), centroids[0].e(2)]));\n  for (var col = 1; col < cols - 1; ++col) {\n    var mid = centroids[col];\n    var left = centroids[col - 1];\n    var right = centroids[col + 1];\n\n    var diff = left.subtract(right);\n    cps.push(mid.add(diff.x(a)));\n    cps.push(mid);\n    cps.push(mid.subtract(diff.x(a)));\n  }\n\n  cps.push(new Vector([centroids[cols - 1].e(1) + a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)), centroids[cols - 1].e(2)]));\n  cps.push(centroids[cols - 1]);\n\n  return cps;\n};\n\n// draw single cubic bezier curve\n\nvar singleCurve = function singleCurve(config, position, d, ctx) {\n  var centroids = computeCentroids(config, position, d);\n  var cps = computeControlPoints(config.smoothness, centroids);\n\n  ctx.moveTo(cps[0].e(1), cps[0].e(2));\n\n  for (var i = 1; i < cps.length; i += 3) {\n    if (config.showControlPoints) {\n      for (var j = 0; j < 3; j++) {\n        ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n      }\n    }\n    ctx.bezierCurveTo(cps[i].e(1), cps[i].e(2), cps[i + 1].e(1), cps[i + 1].e(2), cps[i + 2].e(1), cps[i + 2].e(2));\n  }\n};\n\n// returns the y-position just beyond the separating null value line\nvar getNullPosition = function getNullPosition(config) {\n  if (config.nullValueSeparator === 'bottom') {\n    return h(config) + 1;\n  } else if (config.nullValueSeparator === 'top') {\n    return 1;\n  } else {\n    console.log(\"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\");\n  }\n  return h(config) + 1;\n};\n\nvar singlePath = function singlePath(config, position, d, ctx) {\n  Object.keys(config.dimensions).map(function (p) {\n    return [position(p), d[p] === undefined ? getNullPosition(config) : config.dimensions[p].yscale(d[p])];\n  }).sort(function (a, b) {\n    return a[0] - b[0];\n  }).forEach(function (p, i) {\n    i === 0 ? ctx.moveTo(p[0], p[1]) : ctx.lineTo(p[0], p[1]);\n  });\n};\n\n// draw single polyline\nvar colorPath = function colorPath(config, position, d, ctx) {\n  ctx.beginPath();\n  if (config.bundleDimension !== null && config.bundlingStrength > 0 || config.smoothness > 0) {\n    singleCurve(config, position, d, ctx);\n  } else {\n    singlePath(config, position, d, ctx);\n  }\n  ctx.stroke();\n};\n\nvar _functor = function _functor(v) {\n  return typeof v === 'function' ? v : function () {\n    return v;\n  };\n};\n\nvar pathMark = function pathMark(config, ctx, position) {\n  return function (d, i) {\n    ctx.marked.strokeStyle = _functor(config.color)(d, i);\n    return colorPath(config, position, d, ctx.marked);\n  };\n};\n\nvar renderMarkedDefault = function renderMarkedDefault(config, pc, ctx, position) {\n  return function () {\n    pc.clear('marked');\n\n    if (config.marked.length) {\n      config.marked.forEach(pathMark(config, ctx, position));\n    }\n  };\n};\n\nvar renderMarkedQueue = function renderMarkedQueue(config, markedQueue) {\n  return function () {\n    if (config.marked) {\n      markedQueue(config.marked);\n    } else {\n      markedQueue([]); // This is needed to clear the currently marked items\n    }\n  };\n};\n\nvar renderMarked = function renderMarked(config, pc, events) {\n  return function () {\n    if (!Object.keys(config.dimensions).length) pc.detectDimensions();\n\n    pc.renderMarked[config.mode]();\n    events.call('render', this);\n    return this;\n  };\n};\n\nvar pathBrushed = function pathBrushed(config, ctx, position) {\n  return function (d, i) {\n    if (config.brushedColor !== null) {\n      ctx.brushed.strokeStyle = _functor(config.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = _functor(config.color)(d, i);\n    }\n    return colorPath(config, position, d, ctx.brushed);\n  };\n};\n\nvar renderBrushedDefault = function renderBrushedDefault(config, ctx, position, pc, brushGroup) {\n  return function () {\n    pc.clear('brushed');\n\n    if (isBrushed(config, brushGroup) && config.brushed !== false) {\n      config.brushed.forEach(pathBrushed(config, ctx, position));\n    }\n  };\n};\n\nvar renderBrushedQueue = function renderBrushedQueue(config, brushGroup, brushedQueue) {\n  return function () {\n    if (isBrushed(config, brushGroup)) {\n      brushedQueue(config.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n};\n\nvar renderBrushed = function renderBrushed(config, pc, events) {\n  return function () {\n    if (!Object.keys(config.dimensions).length) pc.detectDimensions();\n\n    pc.renderBrushed[config.mode]();\n    events.call('render', this);\n    return this;\n  };\n};\n\nvar brushReset$4 = function brushReset(config) {\n  return function (dimension) {\n    var brushesToKeep = [];\n    for (var j = 0; j < config.brushes.length; j++) {\n      if (config.brushes[j].data !== dimension) {\n        brushesToKeep.push(config.brushes[j]);\n      }\n    }\n\n    config.brushes = brushesToKeep;\n    config.brushed = false;\n\n    if (pc.g() !== undefined) {\n      var nodes = pc.g().selectAll('.brush').nodes();\n      for (var i = 0; i < nodes.length; i++) {\n        if (nodes[i].__data__ === dimension) {\n          // remove all dummy brushes for this axis or the real brush\n          select(select(nodes[i]).nodes()[0].parentNode).selectAll('.dummy').remove();\n          config.dimensions[dimension].brush.move(select(nodes[i], null));\n        }\n      }\n    }\n\n    return this;\n  };\n};\n\n// a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\nvar toType = function toType(v) {\n  return {}.toString.call(v).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n};\n\n// this descriptive text should live with other introspective methods\nvar toString = function toString(config) {\n  return function () {\n    return 'Parallel Coordinates: ' + Object.keys(config.dimensions).length + ' dimensions (' + Object.keys(config.data[0]).length + ' total) , ' + config.data.length + ' rows';\n  };\n};\n\n// pairs of adjacent dimensions\nvar adjacentPairs = function adjacentPairs(arr) {\n  var ret = [];\n  for (var i = 0; i < arr.length - 1; i++) {\n    ret.push([arr[i], arr[i + 1]]);\n  }\n  return ret;\n};\n\nvar pathHighlight = function pathHighlight(config, ctx, position) {\n  return function (d, i) {\n    ctx.highlight.strokeStyle = _functor(config.color)(d, i);\n    return colorPath(config, position, d, ctx.highlight);\n  };\n};\n\n// highlight an array of data\nvar highlight = function highlight(config, pc, canvas, events, ctx, position) {\n  return function () {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (data === null) {\n      return config.highlighted;\n    }\n\n    config.highlighted = data;\n    pc.clear('highlight');\n    selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(pathHighlight(config, ctx, position));\n    events.call('highlight', this, data);\n    return this;\n  };\n};\n\n// clear highlighting\nvar unhighlight = function unhighlight(config, pc, canvas) {\n  return function () {\n    config.highlighted = [];\n    pc.clear('highlight');\n    selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  };\n};\n\n// mark an array of data\nvar mark = function mark(config, pc, canvas, events, ctx, position) {\n  return function () {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (data === null) {\n      return config.marked;\n    }\n\n    // add array to already marked data\n    config.marked = config.marked.concat(data);\n    selectAll([canvas.foreground, canvas.brushed]).classed('dimmed', true);\n    data.forEach(pathMark(config, ctx, position));\n    events.call('mark', this, data);\n    return this;\n  };\n};\n\n// clear marked data arrays\nvar unmark = function unmark(config, pc, canvas) {\n  return function () {\n    config.marked = [];\n    pc.clear('marked');\n    selectAll([canvas.foreground, canvas.brushed]).classed('dimmed', false);\n    return this;\n  };\n};\n\nvar removeAxes = function removeAxes(pc) {\n  return function () {\n    pc._g.remove();\n\n    delete pc._g;\n    return this;\n  };\n};\n\n/**\n * Renders the polylines.\n * If no dimensions have been specified, it will attempt to detect quantitative\n * dimensions based on the first data entry. If scales haven't been set, it will\n * autoscale based on the extent for each dimension.\n *\n * @param config\n * @param pc\n * @param events\n * @returns {Function}\n */\nvar render = function render(config, pc, events) {\n  return function () {\n    // try to autodetect dimensions and create scales\n    if (!Object.keys(config.dimensions).length) {\n      pc.detectDimensions();\n    }\n    pc.autoscale();\n\n    pc.render[config.mode]();\n\n    events.call('render', this);\n    return this;\n  };\n};\n\nvar pathForeground = function pathForeground(config, ctx, position) {\n  return function (d, i) {\n    ctx.foreground.strokeStyle = _functor(config.color)(d, i);\n    return colorPath(config, position, d, ctx.foreground);\n  };\n};\n\nvar renderDefault = function renderDefault(config, pc, ctx, position) {\n  return function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n\n    pc.renderBrushed.default();\n    pc.renderMarked.default();\n\n    config.data.forEach(pathForeground(config, ctx, position));\n  };\n};\n\nvar renderDefaultQueue = function renderDefaultQueue(config, pc, foregroundQueue) {\n  return function () {\n    pc.renderBrushed.queue();\n    pc.renderMarked.queue();\n    foregroundQueue(config.data);\n  };\n};\n\n// try to coerce to number before returning type\nvar toTypeCoerceNumbers = function toTypeCoerceNumbers(v) {\n  return parseFloat(v) == v && v !== null ? 'number' : toType(v);\n};\n\n// attempt to determine types of each dimension based on first row of data\nvar detectDimensionTypes = function detectDimensionTypes(data) {\n  return Object.keys(data[0]).reduce(function (acc, cur) {\n    var key = isNaN(Number(cur)) ? cur : parseInt(cur);\n    acc[key] = toTypeCoerceNumbers(data[0][cur]);\n\n    return acc;\n  }, {});\n};\n\nvar getOrderedDimensionKeys = function getOrderedDimensionKeys(config) {\n  return function () {\n    return Object.keys(config.dimensions).sort(function (x, y) {\n      return ascending(config.dimensions[x].index, config.dimensions[y].index);\n    });\n  };\n};\n\nvar interactive = function interactive(flags) {\n  return function () {\n    flags.interactive = true;\n    return this;\n  };\n};\n\nvar shadows = function shadows(flags, pc) {\n  return function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  };\n};\n\n/**\n * Setup a new parallel coordinates chart.\n *\n * @param config\n * @param canvas\n * @param ctx\n * @returns {pc} a parcoords closure\n */\nvar init = function init(config, canvas, ctx) {\n  /**\n   * Create the chart within a container. The selector can also be a d3 selection.\n   *\n   * @param selection a d3 selection\n   * @returns {pc} instance for chained api\n   */\n  var pc = function pc(selection) {\n    selection = pc.selection = select(selection);\n\n    config.width = selection.node().clientWidth;\n    config.height = selection.node().clientHeight;\n    // canvas data layers\n    ['dots', 'foreground', 'brushed', 'marked', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer).node();\n      ctx[layer] = canvas[layer].getContext('2d');\n    });\n\n    // svg tick and brush layers\n    pc.svg = selection.append('svg').attr('width', config.width).attr('height', config.height).style('font', '14px sans-serif').style('position', 'absolute').append('svg:g').attr('transform', 'translate(' + config.margin.left + ',' + config.margin.top + ')');\n    // for chained api\n    return pc;\n  };\n\n  // for partial-application style programming\n  return pc;\n};\n\nvar flip = function flip(config) {\n  return function (d) {\n    //__.dimensions[d].yscale.domain().reverse();                               // does not work\n    config.dimensions[d].yscale.domain(config.dimensions[d].yscale.domain().reverse()); // works\n\n    return this;\n  };\n};\n\nvar detectDimensions = function detectDimensions(pc) {\n  return function () {\n    pc.dimensions(pc.applyDimensionDefaults());\n    return this;\n  };\n};\n\nvar scale = function scale(config, pc) {\n  return function (d, domain) {\n    config.dimensions[d].yscale.domain(domain);\n    pc.render.default();\n    pc.updateAxes();\n\n    return this;\n  };\n};\n\nvar version = \"2.2.9\";\n\nvar DefaultConfig = {\n  data: [],\n  highlighted: [],\n  marked: [],\n  dimensions: {},\n  dimensionTitleRotation: 0,\n  brushes: [],\n  brushed: false,\n  brushedColor: null,\n  alphaOnBrushed: 0.0,\n  lineWidth: 1.4,\n  highlightedLineWidth: 3,\n  mode: 'default',\n  markedLineWidth: 3,\n  markedShadowColor: '#ffffff',\n  markedShadowBlur: 10,\n  rate: 20,\n  width: 600,\n  height: 300,\n  margin: { top: 24, right: 20, bottom: 12, left: 20 },\n  nullValueSeparator: 'undefined', // set to \"top\" or \"bottom\"\n  nullValueSeparatorPadding: { top: 8, right: 0, bottom: 8, left: 0 },\n  color: '#069',\n  composite: 'source-over',\n  alpha: 0.7,\n  bundlingStrength: 0.5,\n  bundleDimension: null,\n  smoothness: 0.0,\n  showControlPoints: false,\n  hideAxis: [],\n  flipAxes: [],\n  animationTime: 1100, // How long it takes to flip the axis when you double click\n  rotateLabels: false\n};\n\nvar _this$4 = undefined;\n\nvar initState = function initState(userConfig) {\n  var config = Object.assign({}, DefaultConfig, userConfig);\n\n  if (userConfig && userConfig.dimensionTitles) {\n    console.warn('dimensionTitles passed in userConfig is deprecated. Add title to dimension object.');\n    entries(userConfig.dimensionTitles).forEach(function (d) {\n      if (config.dimensions[d.key]) {\n        config.dimensions[d.key].title = config.dimensions[d.key].title ? config.dimensions[d.key].title : d.value;\n      } else {\n        config.dimensions[d.key] = {\n          title: d.value\n        };\n      }\n    });\n  }\n\n  var eventTypes = ['render', 'resize', 'highlight', 'mark', 'brush', 'brushend', 'brushstart', 'axesreorder'].concat(keys(config));\n\n  var events = dispatch.apply(_this$4, eventTypes),\n      flags = {\n    brushable: false,\n    reorderable: false,\n    axes: false,\n    interactive: false,\n    debug: false\n  },\n      xscale = scalePoint(),\n      dragging = {},\n      axis = axisLeft().ticks(5),\n      ctx = {},\n      canvas = {};\n\n  var brush = {\n    modes: {\n      None: {\n        install: function install(pc) {}, // Nothing to be done.\n        uninstall: function uninstall(pc) {}, // Nothing to be done.\n        selected: function selected() {\n          return [];\n        }, // Nothing to return\n        brushState: function brushState() {\n          return {};\n        }\n      }\n    },\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function currentMode() {\n      return this.modes[this.mode];\n    }\n  };\n\n  return {\n    config: config,\n    events: events,\n    eventTypes: eventTypes,\n    flags: flags,\n    xscale: xscale,\n    dragging: dragging,\n    axis: axis,\n    ctx: ctx,\n    canvas: canvas,\n    brush: brush\n  };\n};\n\nvar computeClusterCentroids = function computeClusterCentroids(config, d) {\n  var clusterCentroids = new Map();\n  var clusterCounts = new Map();\n  // determine clusterCounts\n  config.data.forEach(function (row) {\n    var scaled = config.dimensions[d].yscale(row[d]);\n    if (!clusterCounts.has(scaled)) {\n      clusterCounts.set(scaled, 0);\n    }\n    var count = clusterCounts.get(scaled);\n    clusterCounts.set(scaled, count + 1);\n  });\n\n  config.data.forEach(function (row) {\n    Object.keys(config.dimensions).map(function (p) {\n      var scaled = config.dimensions[d].yscale(row[d]);\n      if (!clusterCentroids.has(scaled)) {\n        var _map = new Map();\n        clusterCentroids.set(scaled, _map);\n      }\n      if (!clusterCentroids.get(scaled).has(p)) {\n        clusterCentroids.get(scaled).set(p, 0);\n      }\n      var value = clusterCentroids.get(scaled).get(p);\n      value += config.dimensions[p].yscale(row[p]) / clusterCounts.get(scaled);\n      clusterCentroids.get(scaled).set(p, value);\n    });\n  });\n\n  return clusterCentroids;\n};\n\nvar _this$5 = undefined;\n\nvar without = function without(arr, items) {\n  items.forEach(function (el) {\n    delete arr[el];\n  });\n  return arr;\n};\n\nvar sideEffects = function sideEffects(config, ctx, pc, xscale, axis, flags, brushedQueue, markedQueue, foregroundQueue) {\n  return dispatch.apply(_this$5, Object.keys(config)).on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).on('width', function (d) {\n    return pc.resize();\n  }).on('height', function (d) {\n    return pc.resize();\n  }).on('margin', function (d) {\n    return pc.resize();\n  }).on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    markedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).on('dimensions', function (d) {\n    config.dimensions = pc.applyDimensionDefaults(Object.keys(d.value));\n    xscale.domain(pc.getOrderedDimensionKeys());\n    pc.sortDimensions();\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).on('bundleDimension', function (d) {\n    if (!Object.keys(config.dimensions).length) pc.detectDimensions();\n    pc.autoscale();\n    if (typeof d.value === 'number') {\n      if (d.value < Object.keys(config.dimensions).length) {\n        config.bundleDimension = config.dimensions[d.value];\n      } else if (d.value < config.hideAxis.length) {\n        config.bundleDimension = config.hideAxis[d.value];\n      }\n    } else {\n      config.bundleDimension = d.value;\n    }\n\n    config.clusterCentroids = computeClusterCentroids(config, config.bundleDimension);\n    if (flags.interactive) {\n      pc.render();\n    }\n  }).on('hideAxis', function (d) {\n    pc.dimensions(pc.applyDimensionDefaults());\n    pc.dimensions(without(config.dimensions, d.value));\n  }).on('flipAxes', function (d) {\n    if (d.value && d.value.length) {\n      d.value.forEach(function (dimension) {\n        flipAxisAndUpdatePCP(config, pc, axis)(dimension);\n      });\n      pc.updateAxes(0);\n    }\n  });\n};\n\nvar getset = function getset(obj, state, events, side_effects) {\n  Object.keys(state).forEach(function (key) {\n    obj[key] = function (x) {\n      if (!arguments.length) {\n        return state[key];\n      }\n      if (key === 'dimensions' && Object.prototype.toString.call(x) === '[object Array]') {\n        console.warn('pc.dimensions([]) is deprecated, use pc.dimensions({})');\n        x = obj.applyDimensionDefaults(x);\n      }\n      var old = state[key];\n      state[key] = x;\n      side_effects.call(key, obj, { value: x, previous: old });\n      events.call(key, obj, { value: x, previous: old });\n      return obj;\n    };\n  });\n};\n\n// side effects for setters\n\nvar d3_rebind = function d3_rebind(target, source, method) {\n  return function () {\n    var value = method.apply(source, arguments);\n    return value === source ? target : value;\n  };\n};\n\nvar _rebind = function _rebind(target, source, method) {\n  target[method] = d3_rebind(target, source, source[method]);\n  return target;\n};\n\nvar bindEvents = function bindEvents(__, ctx, pc, xscale, flags, brushedQueue, markedQueue, foregroundQueue, events, axis) {\n  var side_effects = sideEffects(__, ctx, pc, xscale, axis, flags, brushedQueue, markedQueue, foregroundQueue);\n\n  // create getter/setters\n  getset(pc, __, events, side_effects);\n\n  // expose events\n  // getter/setter with event firing\n  _rebind(pc, events, 'on');\n\n  _rebind(pc, axis, 'ticks', 'orient', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat');\n};\n\n// misc\n\nvar ParCoords = function ParCoords(userConfig) {\n  var state = initState(userConfig);\n  var config = state.config,\n      events = state.events,\n      flags = state.flags,\n      xscale = state.xscale,\n      dragging = state.dragging,\n      axis = state.axis,\n      ctx = state.ctx,\n      canvas = state.canvas,\n      brush = state.brush;\n\n\n  var pc = init(config, canvas, ctx);\n\n  var position = function position(d) {\n    if (xscale.range().length === 0) {\n      xscale.range([0, w(config)], 1);\n    }\n    return dragging[d] == null ? xscale(d) : dragging[d];\n  };\n\n  var brushedQueue = renderQueue(pathBrushed(config, ctx, position)).rate(50).clear(function () {\n    return pc.clear('brushed');\n  });\n\n  var markedQueue = renderQueue(pathMark(config, ctx, position)).rate(50).clear(function () {\n    return pc.clear('marked');\n  });\n\n  var foregroundQueue = renderQueue(pathForeground(config, ctx, position)).rate(50).clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  bindEvents(config, ctx, pc, xscale, flags, brushedQueue, markedQueue, foregroundQueue, events, axis);\n\n  // expose the state of the chart\n  pc.state = config;\n  pc.flags = flags;\n\n  pc.autoscale = autoscale(config, pc, xscale, ctx);\n  pc.scale = scale(config, pc);\n  pc.flip = flip(config);\n  pc.commonScale = commonScale(config, pc);\n  pc.detectDimensions = detectDimensions(pc);\n  // attempt to determine types of each dimension based on first row of data\n  pc.detectDimensionTypes = detectDimensionTypes;\n  pc.applyDimensionDefaults = applyDimensionDefaults(config, pc);\n  pc.getOrderedDimensionKeys = getOrderedDimensionKeys(config);\n\n  //Renders the polylines.\n  pc.render = render(config, pc, events);\n  pc.renderBrushed = renderBrushed(config, pc, events);\n  pc.renderMarked = renderMarked(config, pc, events);\n  pc.render.default = renderDefault(config, pc, ctx, position);\n  pc.render.queue = renderDefaultQueue(config, pc, foregroundQueue);\n  pc.renderBrushed.default = renderBrushedDefault(config, ctx, position, pc, brush);\n  pc.renderBrushed.queue = renderBrushedQueue(config, brush, brushedQueue);\n  pc.renderMarked.default = renderMarkedDefault(config, pc, ctx, position);\n  pc.renderMarked.queue = renderMarkedQueue(config, markedQueue);\n\n  pc.compute_real_centroids = computeRealCentroids(config, position);\n  pc.shadows = shadows(flags, pc);\n  pc.axisDots = axisDots(config, pc, position);\n  pc.clear = clear(config, pc, ctx, brush);\n  pc.createAxes = createAxes(config, pc, xscale, flags, axis);\n  pc.removeAxes = removeAxes(pc);\n  pc.updateAxes = updateAxes(config, pc, position, axis, flags);\n  pc.applyAxisConfig = applyAxisConfig;\n  pc.brushable = brushable(config, pc, flags);\n  pc.brushReset = brushReset$4(config);\n  pc.selected = selected$4(config, pc);\n  pc.reorderable = reorderable(config, pc, xscale, position, dragging, flags);\n\n  // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n  pc.reorder = reorder(config, pc, xscale);\n  pc.sortDimensionsByRowData = sortDimensionsByRowData(config);\n  pc.sortDimensions = sortDimensions(config, position);\n\n  // pairs of adjacent dimensions\n  pc.adjacent_pairs = adjacentPairs;\n  pc.interactive = interactive(flags);\n\n  // expose internal state\n  pc.xscale = xscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n  pc.g = function () {\n    return pc._g;\n  };\n\n  // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n  pc.resize = resize(config, pc, flags, events);\n\n  // highlight an array of data\n  pc.highlight = highlight(config, pc, canvas, events, ctx, position);\n  // clear highlighting\n  pc.unhighlight = unhighlight(config, pc, canvas);\n\n  // mark an array of data\n  pc.mark = mark(config, pc, canvas, events, ctx, position);\n  // clear marked data\n  pc.unmark = unmark(config, pc, canvas);\n\n  // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n  pc.intersection = intersection;\n\n  // Merges the canvases and SVG elements into one canvas element which is then passed into the callback\n  // (so you can choose to save it to disk, etc.)\n  pc.mergeParcoords = mergeParcoords(pc);\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n  pc.brushMode = brushMode(brush, config, pc);\n\n  // install brushes\n  install1DAxes(brush, config, pc, events);\n  install2DStrums(brush, config, pc, events, xscale);\n  installAngularBrush(brush, config, pc, events, xscale);\n  install1DMultiAxes(brush, config, pc, events);\n\n  pc.version = version;\n  // this descriptive text should live with other introspective methods\n  pc.toString = toString(config);\n  pc.toType = toType;\n  // try to coerce to number before returning type\n  pc.toTypeCoerceNumbers = toTypeCoerceNumbers;\n\n  return pc;\n};\n\nexport default ParCoords;\n//# sourceMappingURL=parcoords.esm.js.map\n","/**\n * requestAnimationFrame version: \"0.0.23\" Copyright (c) 2011-2012, Cyril Agosta ( cyril.agosta.dev@gmail.com) All Rights Reserved.\n * Available via the MIT license.\n * see: http://github.com/cagosta/requestAnimationFrame for details\n *\n * http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n * requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel\n * MIT license\n *\n */\n\n\n( function( global ) {\n\n\n    ( function() {\n\n\n        if ( global.requestAnimationFrame ) {\n\n            return;\n\n        }\n\n        if ( global.webkitRequestAnimationFrame ) { // Chrome <= 23, Safari <= 6.1, Blackberry 10\n\n            global.requestAnimationFrame = global[ 'webkitRequestAnimationFrame' ];\n            global.cancelAnimationFrame = global[ 'webkitCancelAnimationFrame' ] || global[ 'webkitCancelRequestAnimationFrame' ];\n            return;\n\n        }\n\n        // IE <= 9, Android <= 4.3, very old/rare browsers\n\n        var lastTime = 0;\n\n        global.requestAnimationFrame = function( callback ) {\n\n            var currTime = new Date().getTime();\n\n            var timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\n\n            var id = global.setTimeout( function() {\n\n                callback( currTime + timeToCall );\n\n            }, timeToCall );\n\n            lastTime = currTime + timeToCall;\n\n            return id; // return the id for cancellation capabilities\n\n        };\n\n        global.cancelAnimationFrame = function( id ) {\n\n            clearTimeout( id );\n\n        };\n\n    } )();\n\n    if ( typeof define === 'function' ) {\n\n        define( function() {\n\n            return global.requestAnimationFrame;\n\n        } );\n\n    }\n\n} )( window );"],"sourceRoot":""}